"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  BcsType: () => import_bcs3.BcsType,
  Dubhe: () => Dubhe,
  MultiSigClient: () => MultiSigClient,
  SuiAccountManager: () => SuiAccountManager,
  SuiContractFactory: () => SuiContractFactory,
  SuiTx: () => SuiTx,
  bcs: () => import_bcs3.bcs,
  loadMetadata: () => loadMetadata
});
module.exports = __toCommonJS(src_exports);
__reExport(src_exports, require("@mysten/sui/client"), module.exports);
__reExport(src_exports, require("@mysten/sui/utils"), module.exports);
__reExport(src_exports, require("@mysten/sui/transactions"), module.exports);
__reExport(src_exports, require("@mysten/sui/bcs"), module.exports);
__reExport(src_exports, require("@mysten/sui/keypairs/ed25519"), module.exports);
__reExport(src_exports, require("@mysten/sui/keypairs/secp256k1"), module.exports);
__reExport(src_exports, require("@mysten/sui/keypairs/secp256r1"), module.exports);
var import_bcs3 = require("@mysten/bcs");

// src/dubhe.ts
var import_keccak256 = __toESM(require("keccak256"));
var import_client2 = require("@mysten/sui/client");
var import_transactions3 = require("@mysten/sui/transactions");

// src/libs/suiAccountManager/index.ts
var import_ed255192 = require("@mysten/sui/keypairs/ed25519");

// src/libs/suiAccountManager/keypair.ts
var import_ed25519 = require("@mysten/sui/keypairs/ed25519");
var getDerivePathForSUI = (derivePathParams = {}) => {
  const {
    accountIndex = 0,
    isExternal = false,
    addressIndex = 0
  } = derivePathParams;
  return `m/44'/784'/${accountIndex}'/${isExternal ? 1 : 0}'/${addressIndex}'`;
};
var getKeyPair = (mnemonics, derivePathParams = {}) => {
  const derivePath = getDerivePathForSUI(derivePathParams);
  return import_ed25519.Ed25519Keypair.deriveKeypair(mnemonics, derivePath);
};

// src/libs/suiAccountManager/util.ts
var import_utils = require("@mysten/sui/utils");
var isHex = (str) => /^0x[0-9a-fA-F]+$|^[0-9a-fA-F]+$/.test(str);
var isBase64 = (str) => /^[a-zA-Z0-9+/]+={0,2}$/g.test(str);
var fromHEX = (hexStr) => {
  if (!hexStr) {
    throw new Error("cannot parse empty string to Uint8Array");
  }
  const intArr = hexStr.replace("0x", "").match(/.{1,2}/g)?.map((byte) => parseInt(byte, 16));
  if (!intArr || intArr.length === 0) {
    throw new Error(`Unable to parse HEX: ${hexStr}`);
  }
  return Uint8Array.from(intArr);
};
var hexOrBase64ToUint8Array = (str) => {
  if (isHex(str)) {
    return fromHEX(str);
  } else if (isBase64(str)) {
    return (0, import_utils.fromB64)(str);
  } else {
    throw new Error("The string is not a valid hex or base64 string.");
  }
};
var PRIVATE_KEY_SIZE = 32;
var LEGACY_PRIVATE_KEY_SIZE = 64;
var normalizePrivateKey = (key) => {
  if (key.length === LEGACY_PRIVATE_KEY_SIZE) {
    key = key.slice(0, PRIVATE_KEY_SIZE);
  } else if (key.length === PRIVATE_KEY_SIZE + 1 && key[0] === 0) {
    return key.slice(1);
  } else if (key.length === PRIVATE_KEY_SIZE) {
    return key;
  }
  throw new Error("invalid secret key");
};

// src/libs/suiAccountManager/crypto.ts
var import_bip39 = require("@scure/bip39");
var import_english = require("@scure/bip39/wordlists/english");
var generateMnemonic = (numberOfWords = 24) => {
  const strength = numberOfWords === 12 ? 128 : 256;
  return (0, import_bip39.generateMnemonic)(import_english.wordlist, strength);
};

// src/libs/suiAccountManager/index.ts
var import_cryptography = require("@mysten/sui/cryptography");
var SuiAccountManager = class {
  /**
   * Support the following ways to init the SuiToolkit:
   * 1. mnemonics
   * 2. secretKey (base64 or hex)
   * If none of them is provided, will generate a random mnemonics with 24 words.
   *
   * @param mnemonics, 12 or 24 mnemonics words, separated by space
   * @param secretKey, base64 or hex string or Bech32 string, when mnemonics is provided, secretKey will be ignored
   */
  constructor({ mnemonics, secretKey } = {}) {
    this.mnemonics = mnemonics || "";
    this.secretKey = secretKey || "";
    if (!this.mnemonics && !this.secretKey) {
      this.mnemonics = generateMnemonic(24);
    }
    this.currentKeyPair = this.secretKey ? this.parseSecretKey(this.secretKey) : getKeyPair(this.mnemonics);
    this.currentAddress = this.currentKeyPair.getPublicKey().toSuiAddress();
  }
  /**
   * Check if the secretKey starts with bench32 format
   */
  parseSecretKey(secretKey) {
    if (secretKey.startsWith(import_cryptography.SUI_PRIVATE_KEY_PREFIX)) {
      const { secretKey: uint8ArraySecretKey } = (0, import_cryptography.decodeSuiPrivateKey)(secretKey);
      return import_ed255192.Ed25519Keypair.fromSecretKey(
        normalizePrivateKey(uint8ArraySecretKey)
      );
    }
    return import_ed255192.Ed25519Keypair.fromSecretKey(
      normalizePrivateKey(hexOrBase64ToUint8Array(secretKey))
    );
  }
  /**
   * if derivePathParams is not provided or mnemonics is empty, it will return the currentKeyPair.
   * else:
   * it will generate keyPair from the mnemonic with the given derivePathParams.
   */
  getKeyPair(derivePathParams) {
    if (!derivePathParams || !this.mnemonics)
      return this.currentKeyPair;
    return getKeyPair(this.mnemonics, derivePathParams);
  }
  /**
   * if derivePathParams is not provided or mnemonics is empty, it will return the currentAddress.
   * else:
   * it will generate address from the mnemonic with the given derivePathParams.
   */
  getAddress(derivePathParams) {
    if (!derivePathParams || !this.mnemonics)
      return this.currentAddress;
    return getKeyPair(this.mnemonics, derivePathParams).getPublicKey().toSuiAddress();
  }
  /**
   * Switch the current account with the given derivePathParams.
   * This is only useful when the mnemonics is provided. For secretKey mode, it will always use the same account.
   */
  switchAccount(derivePathParams) {
    if (this.mnemonics) {
      this.currentKeyPair = getKeyPair(this.mnemonics, derivePathParams);
      this.currentAddress = this.currentKeyPair.getPublicKey().toSuiAddress();
    }
  }
};

// src/libs/suiTxBuilder/index.ts
var import_transactions2 = require("@mysten/sui/transactions");
var import_utils3 = require("@mysten/sui/utils");

// src/libs/suiTxBuilder/util.ts
var import_utils2 = require("@mysten/sui/utils");
var import_transactions = require("@mysten/sui/transactions");
var import_bcs = require("@mysten/bcs");
var getDefaultSuiInputType = (value) => {
  if (typeof value === "string" && (0, import_utils2.isValidSuiObjectId)(value)) {
    return "object";
  } else if (typeof value === "number" || typeof value === "bigint") {
    return "u64";
  } else if (typeof value === "boolean") {
    return "bool";
  } else {
    return void 0;
  }
};
function makeVecParam(txBlock, args, type) {
  if (args.length === 0)
    throw new Error("Transaction builder error: Empty array is not allowed");
  const defaultSuiType = getDefaultSuiInputType(args[0]);
  const VECTOR_REGEX = /^vector<(.+)>$/;
  const STRUCT_REGEX = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;
  type = type || defaultSuiType;
  if (type === "object") {
    const elements = args.map(
      (arg) => typeof arg === "string" && (0, import_utils2.isValidSuiObjectId)(arg) ? txBlock.object((0, import_utils2.normalizeSuiObjectId)(arg)) : convertObjArg(txBlock, arg)
    );
    return txBlock.makeMoveVec({ elements });
  } else if (typeof type === "string" && !VECTOR_REGEX.test(type) && !STRUCT_REGEX.test(type)) {
    const bcsSchema = (0, import_transactions.getPureBcsSchema)(type);
    return txBlock.pure(import_bcs.bcs.vector(bcsSchema).serialize(args));
  } else {
    const elements = args.map(
      (arg) => convertObjArg(txBlock, arg)
    );
    return txBlock.makeMoveVec({ elements, type });
  }
}
function isMoveVecArg(arg) {
  if (typeof arg === "object" && "vecType" in arg && "value" in arg) {
    return true;
  } else if (Array.isArray(arg)) {
    return true;
  }
  return false;
}
function convertArgs(txBlock, args) {
  return args.map((arg) => {
    if (arg instanceof import_bcs.SerializedBcs || (0, import_bcs.isSerializedBcs)(arg)) {
      return txBlock.pure(arg);
    }
    if (isMoveVecArg(arg)) {
      const vecType = "vecType" in arg;
      return vecType ? makeVecParam(txBlock, arg.value, arg.vecType) : makeVecParam(txBlock, arg);
    }
    return arg;
  });
}
function convertAddressArg(txBlock, arg) {
  if (typeof arg === "string" && (0, import_utils2.isValidSuiAddress)(arg)) {
    return txBlock.pure.address((0, import_utils2.normalizeSuiAddress)(arg));
  } else {
    return convertArgs(txBlock, [arg])[0];
  }
}
function convertObjArg(txb, arg) {
  if (typeof arg === "string") {
    return txb.object(arg);
  }
  if ("digest" in arg && "version" in arg && "objectId" in arg) {
    return txb.objectRef(arg);
  }
  if ("objectId" in arg && "initialSharedVersion" in arg && "mutable" in arg) {
    return txb.sharedObjectRef(arg);
  }
  if ("Object" in arg) {
    if ("ImmOrOwnedObject" in arg.Object) {
      return txb.object(import_transactions.Inputs.ObjectRef(arg.Object.ImmOrOwnedObject));
    } else if ("SharedObject" in arg.Object) {
      return txb.object(import_transactions.Inputs.SharedObjectRef(arg.Object.SharedObject));
    } else {
      throw new Error("Invalid argument type");
    }
  }
  if (typeof arg === "function") {
    return arg;
  }
  if ("GasCoin" in arg || "Input" in arg || "Result" in arg || "NestedResult" in arg) {
    return arg;
  }
  throw new Error("Invalid argument type");
}
function convertAmounts(txBlock, amounts) {
  return amounts.map((amount) => {
    if (typeof amount === "number" || typeof amount === "bigint") {
      return amount;
    } else {
      return convertArgs(txBlock, [amount])[0];
    }
  });
}

// src/libs/suiTxBuilder/index.ts
var SuiTx = class {
  constructor(transaction) {
    if (transaction !== void 0) {
      this.tx = import_transactions2.Transaction.from(transaction);
    } else {
      this.tx = new import_transactions2.Transaction();
    }
  }
  /* Directly wrap methods and properties of TransactionBlock */
  get gas() {
    return this.tx.gas;
  }
  get blockData() {
    return this.tx.blockData;
  }
  address(value) {
    return this.tx.pure.address(value);
  }
  get pure() {
    return this.tx.pure;
  }
  object(value) {
    return this.tx.object(value);
  }
  objectRef(ref) {
    return this.tx.objectRef(ref);
  }
  sharedObjectRef(ref) {
    return this.tx.sharedObjectRef(ref);
  }
  setSender(sender) {
    return this.tx.setSender(sender);
  }
  setSenderIfNotSet(sender) {
    return this.tx.setSenderIfNotSet(sender);
  }
  setExpiration(expiration) {
    return this.tx.setExpiration(expiration);
  }
  setGasPrice(price) {
    return this.tx.setGasPrice(price);
  }
  setGasBudget(budget) {
    return this.tx.setGasBudget(budget);
  }
  setGasOwner(owner) {
    return this.tx.setGasOwner(owner);
  }
  setGasPayment(payments) {
    return this.tx.setGasPayment(payments);
  }
  serialize() {
    return this.tx.serialize();
  }
  toJSON() {
    return this.tx.toJSON();
  }
  sign(params) {
    return this.tx.sign(params);
  }
  build(params = {}) {
    return this.tx.build(params);
  }
  getDigest(params = {}) {
    return this.tx.getDigest(params);
  }
  add(...args) {
    return this.tx.add(...args);
  }
  publish({
    modules,
    dependencies
  }) {
    return this.tx.publish({ modules, dependencies });
  }
  upgrade(...args) {
    return this.tx.upgrade(...args);
  }
  makeMoveVec(...args) {
    return this.tx.makeMoveVec(...args);
  }
  /* Override methods of TransactionBlock */
  transferObjects(objects, address) {
    return this.tx.transferObjects(
      objects.map((object) => convertObjArg(this.tx, object)),
      convertAddressArg(this.tx, address)
    );
  }
  splitCoins(coin, amounts) {
    const res = this.tx.splitCoins(
      convertObjArg(this.tx, coin),
      convertAmounts(this.tx, amounts)
    );
    return amounts.map((_, i) => res[i]);
  }
  mergeCoins(destination, sources) {
    const destinationObject = convertObjArg(this.tx, destination);
    const sourceObjects = sources.map(
      (source) => convertObjArg(this.tx, source)
    );
    return this.tx.mergeCoins(destinationObject, sourceObjects);
  }
  /**
   * @description Move call
   * @param target `${string}::${string}::${string}`, e.g. `0x3::sui_system::request_add_stake`
   * @param args the arguments of the move call, such as `['0x1', '0x2']`
   * @param typeArgs the type arguments of the move call, such as `['0x2::sui::SUI']`
   */
  moveCall(target, args = [], typeArgs = []) {
    const regex = /(?<package>[a-zA-Z0-9]+)::(?<module>[a-zA-Z0-9_]+)::(?<function>[a-zA-Z0-9_]+)/;
    const match = target.match(regex);
    if (match === null)
      throw new Error(
        "Invalid target format. Expected `${string}::${string}::${string}`"
      );
    const convertedArgs = convertArgs(this.tx, args);
    return this.tx.moveCall({
      target,
      arguments: convertedArgs,
      typeArguments: typeArgs
    });
  }
  /* Enhance methods of TransactionBlock */
  transferSuiToMany(recipients, amounts) {
    if (recipients.length !== amounts.length) {
      throw new Error(
        "transferSuiToMany: recipients.length !== amounts.length"
      );
    }
    const coins = this.tx.splitCoins(
      this.tx.gas,
      amounts.map(
        (amount) => typeof amount === "number" || typeof amount === "bigint" ? amount : convertArgs(this.tx, [amount])[0]
      )
    );
    const recipientObjects = recipients.map(
      (recipient) => convertAddressArg(this.tx, recipient)
    );
    recipientObjects.forEach((address, index) => {
      this.tx.transferObjects([coins[index]], address);
    });
    return this;
  }
  transferSui(address, amount) {
    return this.transferSuiToMany([address], [amount]);
  }
  takeAmountFromCoins(coins, amount) {
    const coinObjects = coins.map((coin) => convertObjArg(this.tx, coin));
    const mergedCoin = coinObjects[0];
    if (coins.length > 1) {
      this.tx.mergeCoins(mergedCoin, coinObjects.slice(1));
    }
    const [sendCoin] = this.tx.splitCoins(
      mergedCoin,
      convertAmounts(this.tx, [amount])
    );
    return [sendCoin, mergedCoin];
  }
  splitSUIFromGas(amounts) {
    return this.tx.splitCoins(this.tx.gas, convertAmounts(this.tx, amounts));
  }
  splitMultiCoins(coins, amounts) {
    const coinObjects = coins.map((coin) => convertObjArg(this.tx, coin));
    const mergedCoin = coinObjects[0];
    if (coins.length > 1) {
      this.tx.mergeCoins(mergedCoin, coinObjects.slice(1));
    }
    const splitedCoins = this.tx.splitCoins(
      mergedCoin,
      convertAmounts(this.tx, amounts)
    );
    return { splitedCoins, mergedCoin };
  }
  transferCoinToMany(coins, sender, recipients, amounts) {
    if (recipients.length !== amounts.length) {
      throw new Error(
        "transferSuiToMany: recipients.length !== amounts.length"
      );
    }
    const coinObjects = coins.map((coin) => convertObjArg(this.tx, coin));
    const { splitedCoins, mergedCoin } = this.splitMultiCoins(
      coinObjects,
      amounts
    );
    const recipientObjects = recipients.map(
      (recipient) => convertAddressArg(this.tx, recipient)
    );
    recipientObjects.forEach((address, index) => {
      this.tx.transferObjects([splitedCoins[index]], address);
    });
    this.tx.transferObjects([mergedCoin], convertAddressArg(this.tx, sender));
    return this;
  }
  transferCoin(coins, sender, recipient, amount) {
    return this.transferCoinToMany(coins, sender, [recipient], [amount]);
  }
  stakeSui(amount, validatorAddr) {
    const [stakeCoin] = this.tx.splitCoins(
      this.tx.gas,
      convertAmounts(this.tx, [amount])
    );
    return this.tx.moveCall({
      target: "0x3::sui_system::request_add_stake",
      arguments: convertArgs(this.tx, [
        this.tx.object(import_utils3.SUI_SYSTEM_STATE_OBJECT_ID),
        stakeCoin,
        convertAddressArg(this.tx, validatorAddr)
      ])
    });
  }
};

// src/libs/suiInteractor/suiInteractor.ts
var import_client = require("@mysten/sui/client");
var import_faucet = require("@mysten/sui/faucet");

// src/libs/suiModel/suiOwnedObject.ts
var SuiOwnedObject = class {
  constructor(param) {
    this.objectId = param.objectId;
    this.version = param.version;
    this.digest = param.digest;
  }
  /**
   * Check if the object is fully initialized.
   * So that when it's used as an input, it won't be necessary to fetch from fullnode again.
   * Which can save time when sending transactions.
   */
  isFullObject() {
    return !!this.version && !!this.digest;
  }
  asCallArg() {
    if (!this.version || !this.digest) {
      return this.objectId;
    }
    return {
      $kind: "Object",
      Object: {
        $kind: "ImmOrOwnedObject",
        ImmOrOwnedObject: {
          objectId: this.objectId,
          version: this.version,
          digest: this.digest
        }
      }
    };
  }
  /**
   * Update object version & digest based on the transaction response.
   * @param txResponse
   */
  updateFromTxResponse(txResponse) {
    const changes = txResponse.objectChanges;
    if (!changes) {
      throw new Error("Bad transaction response!");
    }
    for (const change of changes) {
      if (change.type === "mutated" && change.objectId === this.objectId) {
        this.digest = change.digest;
        this.version = change.version;
        return;
      }
    }
    throw new Error("Could not find object in transaction response!");
  }
};

// src/libs/suiModel/suiSharedObject.ts
var SuiSharedObject = class {
  constructor(param) {
    this.objectId = param.objectId;
    this.initialSharedVersion = param.initialSharedVersion;
  }
  asCallArg(mutable = false) {
    if (!this.initialSharedVersion) {
      return this.objectId;
    }
    return {
      $kind: "Object",
      Object: {
        $kind: "SharedObject",
        SharedObject: {
          objectId: this.objectId,
          initialSharedVersion: this.initialSharedVersion,
          mutable
        }
      }
    };
  }
};

// src/libs/suiInteractor/util.ts
var delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

// src/libs/suiInteractor/suiInteractor.ts
var SuiInteractor = class {
  constructor(fullNodeUrls, network) {
    if (fullNodeUrls.length === 0)
      throw new Error("fullNodeUrls must not be empty");
    this.fullNodes = fullNodeUrls;
    this.clients = fullNodeUrls.map((url) => new import_client.SuiClient({ url }));
    this.currentFullNode = fullNodeUrls[0];
    this.currentClient = this.clients[0];
    this.network = network;
  }
  switchToNextClient() {
    const currentClientIdx = this.clients.indexOf(this.currentClient);
    this.currentClient = this.clients[(currentClientIdx + 1) % this.clients.length];
    this.currentFullNode = this.fullNodes[(currentClientIdx + 1) % this.clients.length];
  }
  async sendTx(transactionBlock, signature) {
    const txResOptions = {
      showEvents: true,
      showEffects: true,
      showObjectChanges: true,
      showBalanceChanges: true
    };
    for (const clientIdx in this.clients) {
      try {
        return await this.clients[clientIdx].executeTransactionBlock({
          transactionBlock,
          signature,
          options: txResOptions
        });
      } catch (err) {
        console.warn(
          `Failed to send transaction with fullnode ${this.fullNodes[clientIdx]}: ${err}`
        );
        await delay(2e3);
      }
    }
    throw new Error("Failed to send transaction with all fullnodes");
  }
  async getObjects(ids, options) {
    const opts = options ?? {
      showContent: true,
      showDisplay: true,
      showType: true,
      showOwner: true
    };
    for (const clientIdx in this.clients) {
      try {
        const objects = await this.clients[clientIdx].multiGetObjects({
          ids,
          options: opts
        });
        const parsedObjects = objects.map((object) => {
          return object.data;
        }).filter((object) => object !== null && object !== void 0);
        return parsedObjects;
      } catch (err) {
        await delay(2e3);
        console.warn(
          `Failed to get objects with fullnode ${this.fullNodes[clientIdx]}: ${err}`
        );
      }
    }
    throw new Error("Failed to get objects with all fullnodes");
  }
  async getObject(id) {
    const objects = await this.getObjects([id]);
    return objects[0];
  }
  async getDynamicFieldObject(parentId, name) {
    for (const clientIdx in this.clients) {
      try {
        return await this.clients[clientIdx].getDynamicFieldObject({
          parentId,
          name
        });
      } catch (err) {
        await delay(2e3);
        console.warn(
          `Failed to get DynamicFieldObject with fullnode ${this.fullNodes[clientIdx]}: ${err}`
        );
      }
    }
    throw new Error("Failed to get DynamicFieldObject with all fullnodes");
  }
  async getDynamicFields(parentId, cursor, limit) {
    for (const clientIdx in this.clients) {
      try {
        return await this.clients[clientIdx].getDynamicFields({
          parentId,
          cursor,
          limit
        });
      } catch (err) {
        await delay(2e3);
        console.warn(
          `Failed to get DynamicFields with fullnode ${this.fullNodes[clientIdx]}: ${err}`
        );
      }
    }
    throw new Error("Failed to get DynamicFields with all fullnodes");
  }
  async getTxDetails(digest) {
    for (const clientIdx in this.clients) {
      try {
        const txResOptions = {
          showEvents: true,
          showEffects: true,
          showObjectChanges: true,
          showBalanceChanges: true
        };
        return await this.clients[clientIdx].getTransactionBlock({
          digest,
          options: txResOptions
        });
      } catch (err) {
        await delay(2e3);
        console.warn(
          `Failed to get TransactionBlocks with fullnode ${this.fullNodes[clientIdx]}: ${err}`
        );
      }
    }
    throw new Error("Failed to get TransactionBlocks with all fullnodes");
  }
  async getOwnedObjects(owner, cursor, limit) {
    for (const clientIdx in this.clients) {
      try {
        return await this.clients[clientIdx].getOwnedObjects({
          owner,
          cursor,
          limit
        });
      } catch (err) {
        await delay(2e3);
        console.warn(
          `Failed to get OwnedObjects with fullnode ${this.fullNodes[clientIdx]}: ${err}`
        );
      }
    }
    throw new Error("Failed to get OwnedObjects with all fullnodes");
  }
  async getNormalizedMoveModulesByPackage(packageId) {
    for (const clientIdx in this.clients) {
      try {
        return await this.clients[clientIdx].getNormalizedMoveModulesByPackage({
          package: packageId
        });
      } catch (err) {
        await delay(2e3);
        console.warn(
          `Failed to get NormalizedMoveModules with fullnode ${this.fullNodes[clientIdx]}: ${err}`
        );
      }
    }
    throw new Error("Failed to get NormalizedMoveModules with all fullnodes");
  }
  /**
   * @description Update objects in a batch
   * @param suiObjects
   */
  async updateObjects(suiObjects) {
    const objectIds = suiObjects.map((obj) => obj.objectId);
    const objects = await this.getObjects(objectIds);
    for (const object of objects) {
      const suiObject = suiObjects.find(
        (obj) => obj.objectId === object?.objectId
      );
      if (suiObject instanceof SuiSharedObject) {
        if (object.owner && typeof object.owner === "object" && "Shared" in object.owner) {
          suiObject.initialSharedVersion = object.owner.Shared.initial_shared_version;
        } else {
          suiObject.initialSharedVersion = void 0;
        }
      } else if (suiObject instanceof SuiOwnedObject) {
        suiObject.version = object?.version;
        suiObject.digest = object?.digest;
      }
    }
  }
  /**
   * @description Select coins that add up to the given amount.
   * @param addr the address of the owner
   * @param amount the amount that is needed for the coin
   * @param coinType the coin type, default is '0x2::SUI::SUI'
   */
  async selectCoins(addr, amount, coinType = "0x2::SUI::SUI") {
    const selectedCoins = [];
    let totalAmount = 0;
    let hasNext = true, nextCursor = null;
    while (hasNext && totalAmount < amount) {
      const coins = await this.currentClient.getCoins({
        owner: addr,
        coinType,
        cursor: nextCursor
      });
      coins.data.sort((a, b) => parseInt(b.balance) - parseInt(a.balance));
      for (const coinData of coins.data) {
        selectedCoins.push({
          objectId: coinData.coinObjectId,
          digest: coinData.digest,
          version: coinData.version,
          balance: coinData.balance
        });
        totalAmount = totalAmount + parseInt(coinData.balance);
        if (totalAmount >= amount) {
          break;
        }
      }
      nextCursor = coins.nextCursor;
      hasNext = coins.hasNextPage;
    }
    if (!selectedCoins.length) {
      throw new Error("No valid coins found for the transaction.");
    }
    return selectedCoins;
  }
  /**
   * @description Select owned objects with objectType.
   * @param addr the address of the owner
   * @param objectType the coin type, default is '0x2::SUI::SUI'
   */
  async selectObjects(addr, objectType) {
    const selectedObjects = [];
    let hasNext = true, nextCursor = null;
    while (hasNext) {
      const ownedObjects = await this.currentClient.getOwnedObjects({
        owner: addr,
        cursor: nextCursor
      });
      for (const objectData of ownedObjects.data) {
        const objectDetail = await this.getObject(objectData.data.objectId);
        if (objectDetail.type === objectType) {
          selectedObjects.push(objectDetail);
        }
      }
      nextCursor = ownedObjects.nextCursor;
      hasNext = ownedObjects.hasNextPage;
    }
    if (!selectedObjects.length) {
      throw new Error("Not own this object found for the transaction.");
    }
    return selectedObjects;
  }
  async requestFaucet(address, network) {
    await (0, import_faucet.requestSuiFromFaucetV0)({
      host: (0, import_faucet.getFaucetHost)(network),
      recipient: address
    });
  }
};

// src/libs/suiContractFactory/index.ts
var SuiContractFactory = class {
  // readonly #query: MapMessageQuery<ApiTypes> = {};
  // readonly #tx: MapMessageTx<ApiTypes> = {};
  /**
   * Support the following ways to init the SuiToolkit:
   * 1. mnemonics
   * 2. secretKey (base64 or hex)
   * If none of them is provided, will generate a random mnemonics with 24 words.
   *
   * @param mnemonics, 12 or 24 mnemonics words, separated by space
   * @param secretKey, base64 or hex string, when mnemonics is provided, secretKey will be ignored
   */
  constructor({ packageId, metadata } = {}) {
    this.packageId = packageId || "";
    this.metadata = metadata || void 0;
  }
  getFuncByModuleName(moduleName) {
    Object.values(this.metadata).forEach(
      (value) => {
        const data = value;
        console.log(`moudle name: ${data.name}`);
        Object.entries(data.exposedFunctions).forEach(([key, value2]) => {
          console.log(`	func name: ${key}`);
          Object.values(value2.parameters).forEach((values) => {
          });
        });
      }
    );
  }
  getAllFunc() {
    Object.values(this.metadata).forEach(
      (value) => {
        const data = value;
        console.log(`moudle name: ${data.name}`);
        Object.entries(data.exposedFunctions).forEach(([key, value2]) => {
          console.log(`	func name: ${key}`);
          console.log(`		${value2.parameters.length}`);
          Object.values(value2.parameters).forEach((values) => {
            console.log(`		args: ${values}`);
          });
        });
      }
    );
  }
  getAllModule() {
    Object.values(this.metadata).forEach(
      (value, index) => {
        const data = value;
        console.log(`${index}. ${data.name}`);
      }
    );
  }
  //   async call(arguments: ({
  //     kind: "Input";
  //     index: number;
  //     type?: "object" | "pure" | undefined;
  //     value?: any;
  // } | {
  //     kind: "GasCoin";
  // } | {
  //     kind: "Result";
  //     index: number;
  // } | {
  //     kind: "NestedResult";
  //     index: number;
  //     resultIndex: number;
  // })[], derivePathParams?: DerivePathParams) {
  //     const tx = new TransactionBlock();
  //     tx.moveCall({
  //       target: `${this.packageId}::${}::${}`,
  //       arguments,
  //     })
  //     return ;
  //   }
};

// src/utils/index.ts
function normalizeHexAddress(input) {
  const hexRegex = /^(0x)?[0-9a-fA-F]{64}$/;
  if (hexRegex.test(input)) {
    if (input.startsWith("0x")) {
      return input;
    } else {
      return "0x" + input;
    }
  } else {
    return null;
  }
}
function numberToAddressHex(num) {
  const hex = num.toString(16);
  const paddedHex = "0x" + hex.padStart(64, "0");
  return paddedHex;
}

// src/dubhe.ts
var import_bcs2 = require("@mysten/bcs");

// src/errors/index.ts
var ContractDataParsingError = class extends Error {
  constructor(dryResult) {
    const error = dryResult?.effects?.status?.error || "";
    const functionMatch = error ? error.match(/function_name: Some\("([^"]+)"\)/) : null;
    const moduleMatch = error ? error.match(/address: ([a-fA-F0-9]+)/) : null;
    const functionName = functionMatch ? functionMatch[1] : "unknown";
    const moduleAddress = moduleMatch ? "0x" + moduleMatch[1] : "unknown";
    const errorMessage = dryResult.error ? dryResult.error : "UNKNOWN_ERROR";
    const message = [
      `
- Function: ${functionName}`,
      `- Module Address: ${moduleAddress}`,
      `- Error Message: ${errorMessage}`
    ].join("\n");
    super(message);
    this.errorType = "ContractDataParsingError";
    this.functionName = functionName;
    this.moduleAddress = moduleAddress;
    this.errorMessage = errorMessage;
  }
};

// src/dubhe.ts
function isUndefined(value) {
  return value === void 0;
}
function withMeta(meta, creator) {
  creator.meta = meta;
  return creator;
}
function createQuery(meta, fn) {
  return withMeta(
    meta,
    async ({
      tx,
      params,
      typeArguments,
      isRaw
    }) => {
      const result = await fn(tx, params, typeArguments, isRaw);
      return result;
    }
  );
}
function createTx(meta, fn) {
  return withMeta(
    meta,
    async ({
      tx,
      params,
      typeArguments,
      isRaw
    }) => {
      return await fn(tx, params, typeArguments, isRaw);
    }
  );
}
var _query, _tx, _object, _exec, _read, _bcs;
var Dubhe = class {
  /**
   * Support the following ways to init the DubheClient:
   * 1. mnemonics
   * 2. secretKey (base64 or hex)
   * If none of them is provided, will generate a random mnemonics with 24 words.
   *
   * @param mnemonics, 12 or 24 mnemonics words, separated by space
   * @param secretKey, base64 or hex string or bech32, when mnemonics is provided, secretKey will be ignored
   * @param networkType, 'testnet' | 'mainnet' | 'devnet' | 'localnet', default is 'devnet'
   * @param fullnodeUrl, the fullnode url, default is the preconfig fullnode url for the given network type
   * @param packageId
   */
  constructor({
    mnemonics,
    secretKey,
    networkType,
    fullnodeUrls,
    packageId,
    metadata
  } = {}) {
    __privateAdd(this, _query, {});
    __privateAdd(this, _tx, {});
    __privateAdd(this, _object, {
      address: import_bcs2.bcs.bytes(32).transform({
        // To change the input type, you need to provide a type definition for the input
        input: (val) => (0, import_bcs2.fromHEX)(val),
        output: (val) => (0, import_bcs2.toHEX)(val)
      }),
      u8: import_bcs2.bcs.u8(),
      u16: import_bcs2.bcs.u16(),
      u32: import_bcs2.bcs.u32(),
      u64: import_bcs2.bcs.u64(),
      u128: import_bcs2.bcs.u128(),
      u256: import_bcs2.bcs.u256(),
      bool: import_bcs2.bcs.bool(),
      "0x1::ascii::String": import_bcs2.bcs.string(),
      "0x1::string::String": import_bcs2.bcs.string(),
      "0x1::option::Option<address>": import_bcs2.bcs.option(
        import_bcs2.bcs.bytes(32).transform({
          // To change the input type, you need to provide a type definition for the input
          input: (val) => (0, import_bcs2.fromHEX)(val),
          output: (val) => (0, import_bcs2.toHEX)(val)
        })
      ),
      "0x1::option::Option<u8>": import_bcs2.bcs.option(import_bcs2.bcs.u8()),
      "0x1::option::Option<u16>": import_bcs2.bcs.option(import_bcs2.bcs.u16()),
      "0x1::option::Option<u32>": import_bcs2.bcs.option(import_bcs2.bcs.u32()),
      "0x1::option::Option<u64>": import_bcs2.bcs.option(import_bcs2.bcs.u64()),
      "0x1::option::Option<u128>": import_bcs2.bcs.option(import_bcs2.bcs.u128()),
      "0x1::option::Option<u256>": import_bcs2.bcs.option(import_bcs2.bcs.u256()),
      "0x1::option::Option<bool>": import_bcs2.bcs.option(import_bcs2.bcs.bool()),
      "0x1::option::Option<vector<address>>": import_bcs2.bcs.option(
        import_bcs2.bcs.vector(
          import_bcs2.bcs.bytes(32).transform({
            // To change the input type, you need to provide a type definition for the input
            input: (val) => (0, import_bcs2.fromHEX)(val),
            output: (val) => (0, import_bcs2.toHEX)(val)
          })
        )
      ),
      "0x1::option::Option<vector<u8>>": import_bcs2.bcs.option(import_bcs2.bcs.vector(import_bcs2.bcs.u8())),
      "0x1::option::Option<vector<u16>>": import_bcs2.bcs.option(import_bcs2.bcs.vector(import_bcs2.bcs.u16())),
      "0x1::option::Option<vector<u32>>": import_bcs2.bcs.option(import_bcs2.bcs.vector(import_bcs2.bcs.u32())),
      "0x1::option::Option<vector<u64>>": import_bcs2.bcs.option(import_bcs2.bcs.vector(import_bcs2.bcs.u64())),
      "0x1::option::Option<vector<u128>>": import_bcs2.bcs.option(import_bcs2.bcs.vector(import_bcs2.bcs.u128())),
      "0x1::option::Option<vector<u256>>": import_bcs2.bcs.option(import_bcs2.bcs.vector(import_bcs2.bcs.u256())),
      "0x1::option::Option<vector<bool>>": import_bcs2.bcs.option(import_bcs2.bcs.vector(import_bcs2.bcs.bool())),
      "vector<address>": import_bcs2.bcs.vector(
        import_bcs2.bcs.bytes(32).transform({
          // To change the input type, you need to provide a type definition for the input
          input: (val) => (0, import_bcs2.fromHEX)(val),
          output: (val) => (0, import_bcs2.toHEX)(val)
        })
      ),
      "vector<u8>": import_bcs2.bcs.vector(import_bcs2.bcs.u8()),
      "vector<u16>": import_bcs2.bcs.vector(import_bcs2.bcs.u16()),
      "vector<u32>": import_bcs2.bcs.vector(import_bcs2.bcs.u32()),
      "vector<u64>": import_bcs2.bcs.vector(import_bcs2.bcs.u64()),
      "vector<u128>": import_bcs2.bcs.vector(import_bcs2.bcs.u128()),
      "vector<u256>": import_bcs2.bcs.vector(import_bcs2.bcs.u256()),
      "vector<bool>": import_bcs2.bcs.vector(import_bcs2.bcs.bool()),
      "vector<vector<address>>": import_bcs2.bcs.vector(
        import_bcs2.bcs.vector(
          import_bcs2.bcs.bytes(32).transform({
            // To change the input type, you need to provide a type definition for the input
            input: (val) => (0, import_bcs2.fromHEX)(val),
            output: (val) => (0, import_bcs2.toHEX)(val)
          })
        )
      ),
      "vector<vector<u8>>": import_bcs2.bcs.vector(import_bcs2.bcs.vector(import_bcs2.bcs.u8())),
      "vector<vector<u16>>": import_bcs2.bcs.vector(import_bcs2.bcs.vector(import_bcs2.bcs.u16())),
      "vector<vector<u32>>": import_bcs2.bcs.vector(import_bcs2.bcs.vector(import_bcs2.bcs.u32())),
      "vector<vector<u64>>": import_bcs2.bcs.vector(import_bcs2.bcs.vector(import_bcs2.bcs.u64())),
      "vector<vector<u128>>": import_bcs2.bcs.vector(import_bcs2.bcs.vector(import_bcs2.bcs.u128())),
      "vector<vector<u256>>": import_bcs2.bcs.vector(import_bcs2.bcs.vector(import_bcs2.bcs.u256())),
      "vector<vector<bool>>": import_bcs2.bcs.vector(import_bcs2.bcs.vector(import_bcs2.bcs.bool()))
    });
    __privateAdd(this, _exec, async (meta, tx, params, typeArguments, isRaw) => {
      if (isRaw === true) {
        return tx.moveCall({
          target: `${this.contractFactory.packageId}::${meta.moduleName}::${meta.funcName}`,
          arguments: params,
          typeArguments
        });
      }
      tx.moveCall({
        target: `${this.contractFactory.packageId}::${meta.moduleName}::${meta.funcName}`,
        arguments: params,
        typeArguments
      });
      return await this.signAndSendTxn(tx);
    });
    __privateAdd(this, _read, async (meta, tx, params, typeArguments, isRaw) => {
      if (isRaw === true) {
        return tx.moveCall({
          target: `${this.contractFactory.packageId}::${meta.moduleName}::${meta.funcName}`,
          arguments: params,
          typeArguments
        });
      }
      tx.moveCall({
        target: `${this.contractFactory.packageId}::${meta.moduleName}::${meta.funcName}`,
        arguments: params,
        typeArguments
      });
      return await this.inspectTxn(tx);
    });
    __privateAdd(this, _bcs, (bcsmeta) => {
      let loopFlag = false;
      const bcsJson = {};
      Object.entries(bcsmeta.objectType.fields).forEach(([index, type]) => {
        const objName = type.name;
        const objType = type.type;
        switch (typeof objType) {
          case "object":
            for (const [key, value] of Object.entries(objType)) {
              switch (key) {
                case "Struct":
                  const structType = value;
                  if (structType.address === "0x1" && structType.module === "ascii" && structType.name === "String") {
                    bcsJson[objName] = import_bcs2.bcs.string();
                    return;
                  } else if (structType.address === "0x2" && structType.module === "object" && structType.name === "UID") {
                    bcsJson[objName] = import_bcs2.bcs.fixedArray(32, import_bcs2.bcs.u8()).transform({
                      input: (id) => (0, import_bcs2.fromHEX)(id),
                      output: (id) => (0, import_bcs2.toHEX)(Uint8Array.from(id))
                    });
                    return;
                  } else if (structType.address === "0x2" && structType.module === "object" && structType.name === "ID") {
                    bcsJson[objName] = import_bcs2.bcs.fixedArray(32, import_bcs2.bcs.u8()).transform({
                      input: (id) => (0, import_bcs2.fromHEX)(id),
                      output: (id) => (0, import_bcs2.toHEX)(Uint8Array.from(id))
                    });
                    return;
                  } else if (structType.address === "0x2" && structType.module === "bag" && structType.name === "Bag") {
                    bcsJson[objName] = import_bcs2.bcs.fixedArray(32, import_bcs2.bcs.u8()).transform({
                      input: (id) => (0, import_bcs2.fromHEX)(id),
                      output: (id) => (0, import_bcs2.toHEX)(Uint8Array.from(id))
                    });
                    return;
                  } else if (structType.address === "0x1" && structType.module === "option" && structType.name === "Option") {
                    switch (structType.typeArguments[0]) {
                      case "U8":
                        bcsJson[objName] = import_bcs2.bcs.option(import_bcs2.bcs.u8());
                        return;
                      case "U16":
                        bcsJson[objName] = import_bcs2.bcs.option(import_bcs2.bcs.u16());
                        return;
                      case "U32":
                        bcsJson[objName] = import_bcs2.bcs.option(import_bcs2.bcs.u32());
                        return;
                      case "U64":
                        bcsJson[objName] = import_bcs2.bcs.option(import_bcs2.bcs.u64());
                        return;
                      case "U128":
                        bcsJson[objName] = import_bcs2.bcs.option(import_bcs2.bcs.u128());
                        return;
                      case "U256":
                        bcsJson[objName] = import_bcs2.bcs.option(import_bcs2.bcs.u256());
                        return;
                      case "Bool":
                        bcsJson[objName] = import_bcs2.bcs.option(import_bcs2.bcs.bool());
                        return;
                      case "Address":
                        bcsJson[objName] = import_bcs2.bcs.option(
                          import_bcs2.bcs.bytes(32).transform({
                            // To change the input type, you need to provide a type definition for the input
                            input: (val) => (0, import_bcs2.fromHEX)(val),
                            output: (val) => (0, import_bcs2.toHEX)(val)
                          })
                        );
                        return;
                      default:
                    }
                  } else {
                    if (this.object[`${structType.address}::${structType.module}::${structType.name}`] === void 0) {
                      loopFlag = true;
                    } else {
                      bcsJson[objName] = this.object[`${structType.address}::${structType.module}::${structType.name}`];
                      return;
                    }
                  }
                  return;
                case "Vector":
                  switch (value) {
                    case "U8":
                      bcsJson[objName] = import_bcs2.bcs.vector(import_bcs2.bcs.u8());
                      return;
                    case "U16":
                      bcsJson[objName] = import_bcs2.bcs.vector(import_bcs2.bcs.u16());
                      return;
                    case "U32":
                      bcsJson[objName] = import_bcs2.bcs.vector(import_bcs2.bcs.u32());
                      return;
                    case "U64":
                      bcsJson[objName] = import_bcs2.bcs.vector(import_bcs2.bcs.u64());
                      return;
                    case "U128":
                      bcsJson[objName] = import_bcs2.bcs.vector(import_bcs2.bcs.u128());
                      return;
                    case "U256":
                      bcsJson[objName] = import_bcs2.bcs.vector(import_bcs2.bcs.u256());
                      return;
                    case "Bool":
                      bcsJson[objName] = import_bcs2.bcs.vector(import_bcs2.bcs.bool());
                      return;
                    case "Address":
                      bcsJson[objName] = import_bcs2.bcs.vector(
                        import_bcs2.bcs.bytes(32).transform({
                          // To change the input type, you need to provide a type definition for the input
                          input: (val) => (0, import_bcs2.fromHEX)(val),
                          output: (val) => (0, import_bcs2.toHEX)(val)
                        })
                      );
                      return;
                    default:
                  }
                case "TypeParameter":
                  bcsJson[objName] = import_bcs2.bcs.u128();
                  return;
                default:
                  throw new Error("Unsupported type");
              }
            }
            return;
          case "string":
            switch (objType) {
              case "U8":
                bcsJson[objName] = import_bcs2.bcs.u8();
                return;
              case "U16":
                bcsJson[objName] = import_bcs2.bcs.u16();
                return;
              case "U32":
                bcsJson[objName] = import_bcs2.bcs.u32();
                return;
              case "U64":
                bcsJson[objName] = import_bcs2.bcs.u64();
                return;
              case "U128":
                bcsJson[objName] = import_bcs2.bcs.u128();
                return;
              case "U256":
                bcsJson[objName] = import_bcs2.bcs.u256();
                return;
              case "Bool":
                bcsJson[objName] = import_bcs2.bcs.bool();
                return;
              case "Address":
                bcsJson[objName] = import_bcs2.bcs.bytes(32).transform({
                  // To change the input type, you need to provide a type definition for the input
                  input: (val) => (0, import_bcs2.fromHEX)(val),
                  output: (val) => (0, import_bcs2.toHEX)(val)
                });
                return;
              default:
                return;
            }
          default:
            throw new Error("Unsupported type");
        }
      });
      return {
        bcs: import_bcs2.bcs.struct(bcsmeta.objectName, bcsJson),
        loopFlag
      };
    });
    this.accountManager = new SuiAccountManager({ mnemonics, secretKey });
    fullnodeUrls = fullnodeUrls || [(0, import_client2.getFullnodeUrl)(networkType ?? "mainnet")];
    this.suiInteractor = new SuiInteractor(fullnodeUrls, networkType);
    this.packageId = packageId;
    if (metadata !== void 0) {
      this.metadata = metadata;
      const maxLoopNum = 5;
      let loopNum = 0;
      let stillNeedFormat = true;
      while (stillNeedFormat === true && loopNum <= maxLoopNum) {
        let loopFlag = false;
        Object.values(metadata).forEach(
          (moudlevalue) => {
            const data = moudlevalue;
            const moduleName = data.name;
            const objMoudleId = `${packageId}::${moduleName}`;
            Object.entries(data.structs).forEach(([objectName, objectType]) => {
              const objectId = `${objMoudleId}::${objectName}`;
              const bcsmeta = {
                objectId,
                objectName,
                objectType
              };
              let bcsObj = __privateGet(this, _bcs).call(this, bcsmeta);
              if (bcsObj.loopFlag === true) {
                loopFlag = bcsObj.loopFlag;
              }
              __privateGet(this, _object)[objectId] = bcsObj.bcs;
              __privateGet(this, _object)[`vector<${objectId}>`] = import_bcs2.bcs.vector(bcsObj.bcs);
              __privateGet(this, _object)[`0x1::option::Option<${objectId}>`] = import_bcs2.bcs.option(
                bcsObj.bcs
              );
            });
            Object.entries(data.exposedFunctions).forEach(
              ([funcName, funcvalue]) => {
                const meta = funcvalue;
                meta.moduleName = moduleName;
                meta.funcName = funcName;
                if (isUndefined(__privateGet(this, _query)[moduleName])) {
                  __privateGet(this, _query)[moduleName] = {};
                }
                if (isUndefined(__privateGet(this, _query)[moduleName][funcName])) {
                  __privateGet(this, _query)[moduleName][funcName] = createQuery(
                    meta,
                    (tx, p, typeArguments, isRaw) => __privateGet(this, _read).call(this, meta, tx, p, typeArguments, isRaw)
                  );
                }
                if (isUndefined(__privateGet(this, _tx)[moduleName])) {
                  __privateGet(this, _tx)[moduleName] = {};
                }
                if (isUndefined(__privateGet(this, _tx)[moduleName][funcName])) {
                  __privateGet(this, _tx)[moduleName][funcName] = createTx(
                    meta,
                    (tx, p, typeArguments, isRaw) => __privateGet(this, _exec).call(this, meta, tx, p, typeArguments, isRaw)
                  );
                }
              }
            );
          }
        );
        stillNeedFormat = loopFlag;
        loopNum++;
      }
    }
    this.contractFactory = new SuiContractFactory({
      packageId,
      metadata
    });
  }
  get query() {
    return __privateGet(this, _query);
  }
  get tx() {
    return __privateGet(this, _tx);
  }
  get object() {
    return __privateGet(this, _object);
  }
  view(dryResult) {
    let returnValues = [];
    if (dryResult.effects.status.status === "success") {
      const resultList = dryResult.results[0].returnValues;
      for (const res of resultList) {
        let baseValue = res[0];
        let baseType = res[1];
        const value = Uint8Array.from(baseValue);
        if (!__privateGet(this, _object)[baseType]) {
          console.log(
            "\n\x1B[41m\x1B[37m ERROR \x1B[0m \x1B[31mUnsupported Type\x1B[0m"
          );
          console.log("\x1B[90m\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\x1B[0m");
          console.log(`\x1B[95m\u2022\x1B[0m Type: \x1B[33m"${baseType}"\x1B[0m`);
          console.log("\x1B[95m\n\u2728 Available Types:\x1B[0m");
          Object.keys(__privateGet(this, _object)).forEach((type) => {
            console.log(`  \x1B[36m\u25C6\x1B[0m ${type}`);
          });
          console.log("\n\x1B[34m\u{1F4A1} How to Add Custom Type:\x1B[0m");
          console.log(
            `  You can add custom type by extending the #object map in your code:`
          );
          console.log(
            `  \x1B[32mdubhe.object["${baseType}"] = bcs.struct("YourTypeName", {
    field1: bcs.string(),
    field2: bcs.u64(),
    // ... other fields
  });\x1B[0m`
          );
          console.log(
            "\x1B[90m\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\x1B[0m\n"
          );
          throw new Error(`Unsupported type: ${baseType}`);
        }
        returnValues.push(__privateGet(this, _object)[baseType].parse(value));
      }
      return returnValues;
    } else {
      throw new ContractDataParsingError(dryResult);
    }
  }
  /**
   * if derivePathParams is not provided or mnemonics is empty, it will return the keypair.
   * else:
   * it will generate signer from the mnemonic with the given derivePathParams.
   * @param derivePathParams, such as { accountIndex: 2, isExternal: false, addressIndex: 10 }, comply with the BIP44 standard
   */
  getKeypair(derivePathParams) {
    return this.accountManager.getKeyPair(derivePathParams);
  }
  /**
   * @description Switch the current account with the given derivePathParams
   * @param derivePathParams, such as { accountIndex: 2, isExternal: false, addressIndex: 10 }, comply with the BIP44 standard
   */
  switchAccount(derivePathParams) {
    this.accountManager.switchAccount(derivePathParams);
  }
  /**
   * @description Get the address of the account for the given derivePathParams
   * @param derivePathParams, such as { accountIndex: 2, isExternal: false, addressIndex: 10 }, comply with the BIP44 standard
   */
  getAddress(derivePathParams) {
    return this.accountManager.getAddress(derivePathParams);
  }
  currentAddress() {
    return this.accountManager.currentAddress;
  }
  getPackageId() {
    return this.contractFactory.packageId;
  }
  getMetadata() {
    return this.contractFactory.metadata;
  }
  getNetwork() {
    return this.suiInteractor.network;
  }
  /**
   * Request some SUI from faucet
   * @Returns {Promise<boolean>}, true if the request is successful, false otherwise.
   */
  async requestFaucet(address, network, derivePathParams) {
    if (address === void 0) {
      address = this.accountManager.getAddress(derivePathParams);
    }
    if (network === void 0) {
      network = this.getNetwork();
    }
    return this.suiInteractor.requestFaucet(address, network);
  }
  async getBalance(coinType, derivePathParams) {
    const owner = this.accountManager.getAddress(derivePathParams);
    return this.suiInteractor.currentClient.getBalance({ owner, coinType });
  }
  async balanceOf(accountAddress, coinType, derivePathParams) {
    if (accountAddress === void 0) {
      accountAddress = this.accountManager.getAddress(derivePathParams);
    }
    const owner = accountAddress;
    return this.suiInteractor.currentClient.getBalance({ owner, coinType });
  }
  client() {
    return this.suiInteractor.currentClient;
  }
  async getObject(objectId) {
    return this.suiInteractor.getObject(objectId);
  }
  async getObjects(objectIds) {
    return this.suiInteractor.getObjects(objectIds);
  }
  async signTxn(tx, derivePathParams) {
    if (tx instanceof SuiTx || tx instanceof import_transactions3.Transaction) {
      tx.setSender(this.getAddress(derivePathParams));
    }
    const txBlock = tx instanceof SuiTx ? tx.tx : tx;
    const txBytes = txBlock instanceof import_transactions3.Transaction ? await txBlock.build({ client: this.client() }) : txBlock;
    const keyPair = this.getKeypair(derivePathParams);
    return await keyPair.signTransaction(txBytes);
  }
  async signAndSendTxn(tx, derivePathParams) {
    const { bytes, signature } = await this.signTxn(tx, derivePathParams);
    return this.suiInteractor.sendTx(bytes, signature);
  }
  async sendTxn(transactionBlock, signature) {
    return this.suiInteractor.sendTx(transactionBlock, signature);
  }
  /**
   * Transfer the given amount of SUI to the recipient
   * @param recipient
   * @param amount
   * @param derivePathParams
   */
  async transferSui(recipient, amount, derivePathParams) {
    const tx = new SuiTx();
    tx.transferSui(recipient, amount);
    return this.signAndSendTxn(tx, derivePathParams);
  }
  /**
   * Transfer to mutliple recipients
   * @param recipients the recipients addresses
   * @param amounts the amounts of SUI to transfer to each recipient, the length of amounts should be the same as the length of recipients
   * @param derivePathParams
   */
  async transferSuiToMany(recipients, amounts, derivePathParams) {
    const tx = new SuiTx();
    tx.transferSuiToMany(recipients, amounts);
    return this.signAndSendTxn(tx, derivePathParams);
  }
  /**
   * Transfer the given amounts of coin to multiple recipients
   * @param recipients the list of recipient address
   * @param amounts the amounts to transfer for each recipient
   * @param coinType any custom coin type but not SUI
   * @param derivePathParams the derive path params for the current signer
   */
  async transferCoinToMany(recipients, amounts, coinType, derivePathParams) {
    const tx = new SuiTx();
    const owner = this.accountManager.getAddress(derivePathParams);
    const totalAmount = amounts.reduce((a, b) => a + b, 0);
    const coins = await this.suiInteractor.selectCoins(
      owner,
      totalAmount,
      coinType
    );
    tx.transferCoinToMany(
      coins.map((c) => c.objectId),
      owner,
      recipients,
      amounts
    );
    return this.signAndSendTxn(tx, derivePathParams);
  }
  async transferCoin(recipient, amount, coinType, derivePathParams) {
    return this.transferCoinToMany(
      [recipient],
      [amount],
      coinType,
      derivePathParams
    );
  }
  async transferObjects(objects, recipient, derivePathParams) {
    const tx = new SuiTx();
    tx.transferObjects(objects, recipient);
    return this.signAndSendTxn(tx, derivePathParams);
  }
  async moveCall(callParams) {
    const {
      target,
      arguments: args = [],
      typeArguments = [],
      derivePathParams
    } = callParams;
    const tx = new SuiTx();
    tx.moveCall(target, args, typeArguments);
    return this.signAndSendTxn(tx, derivePathParams);
  }
  /**
   * Select coins with the given amount and coin type, the total amount is greater than or equal to the given amount
   * @param amount
   * @param coinType
   * @param owner
   */
  async selectCoinsWithAmount(amount, coinType, owner) {
    owner = owner || this.accountManager.currentAddress;
    const coins = await this.suiInteractor.selectCoins(owner, amount, coinType);
    return coins.map((c) => c.objectId);
  }
  async selectObjectsWithType(objectType, owner) {
    owner = owner || this.accountManager.currentAddress;
    const objects = await this.suiInteractor.selectObjects(owner, objectType);
    return objects.map((c) => c.objectId);
  }
  /**
   * stake the given amount of SUI to the validator
   * @param amount the amount of SUI to stake
   * @param validatorAddr the validator address
   * @param derivePathParams the derive path params for the current signer
   */
  async stakeSui(amount, validatorAddr, derivePathParams) {
    const tx = new SuiTx();
    tx.stakeSui(amount, validatorAddr);
    return this.signAndSendTxn(tx, derivePathParams);
  }
  /**
   * Execute the transaction with on-chain data but without really submitting. Useful for querying the effects of a transaction.
   * Since the transaction is not submitted, its gas cost is not charged.
   * @param tx the transaction to execute
   * @param derivePathParams the derive path params
   * @returns the effects and events of the transaction, such as object changes, gas cost, event emitted.
   */
  async inspectTxn(tx, derivePathParams) {
    const txBlock = tx instanceof SuiTx ? tx.tx : tx;
    return this.suiInteractor.currentClient.devInspectTransactionBlock({
      transactionBlock: txBlock,
      sender: this.getAddress(derivePathParams)
    });
  }
  async getOwnedObjects(owner, cursor, limit) {
    const ownedObjects = await this.suiInteractor.getOwnedObjects(
      owner,
      cursor,
      limit
    );
    const ownedObjectsRes = [];
    for (const object of ownedObjects.data) {
      const objectDetail = await this.getObject(object.data.objectId);
      if (objectDetail.type.split("::")[0] === this.contractFactory.packageId) {
        ownedObjectsRes.push(objectDetail);
      }
    }
    return ownedObjectsRes;
  }
  async entity_key_from_object(objectId) {
    const checkObjectId = normalizeHexAddress(objectId);
    if (checkObjectId !== null) {
      objectId = checkObjectId;
      return objectId;
    } else {
      return void 0;
    }
  }
  async entity_key_from_bytes(bytes) {
    const hashBytes = (0, import_keccak256.default)(bytes);
    const hashU8Array = Array.from(hashBytes);
    const value = Uint8Array.from(hashU8Array);
    const Address = import_bcs2.bcs.bytes(32).transform({
      // To change the input type, you need to provide a type definition for the input
      input: (val) => (0, import_bcs2.fromHEX)(val),
      output: (val) => (0, import_bcs2.toHEX)(val)
    });
    const data = Address.parse(value);
    return "0x" + data;
  }
  async entity_key_from_address_with_seed(objectId, seed) {
    const checkObjectId = normalizeHexAddress(objectId);
    if (checkObjectId !== null) {
      objectId = checkObjectId;
      const bytes = Buffer.from(objectId.slice(2), "hex");
      const newBuffer = Buffer.concat([bytes, Buffer.from(seed, "utf-8")]);
      return this.entity_key_from_bytes(newBuffer);
    } else {
      return void 0;
    }
  }
  async entity_key_from_address_with_u256(objectId, x) {
    const checkObjectId = normalizeHexAddress(objectId);
    if (checkObjectId !== null) {
      objectId = checkObjectId;
      const bytes = Buffer.from(objectId.slice(2), "hex");
      const numberBytes = import_bcs2.bcs.u256().serialize(x).toBytes();
      return this.entity_key_from_bytes(Buffer.concat([bytes, numberBytes]));
    } else {
      return void 0;
    }
  }
  async entity_key_from_u256(x) {
    return numberToAddressHex(x);
  }
  // async formatData(type: string, value: Buffer | number[] | Uint8Array) {
  //   const u8Value = Uint8Array.from(value);
  //   return bcs.de(type, u8Value);
  // }
};
_query = new WeakMap();
_tx = new WeakMap();
_object = new WeakMap();
_exec = new WeakMap();
_read = new WeakMap();
_bcs = new WeakMap();

// src/libs/multiSig/client.ts
var import_multisig = require("@mysten/sui/multisig");

// src/libs/multiSig/publickey.ts
var import_ed255193 = require("@mysten/sui/keypairs/ed25519");
var import_utils5 = require("@mysten/sui/utils");
function ed25519PublicKeyFromBase64(rawPubkey) {
  let bytes = (0, import_utils5.fromB64)(rawPubkey);
  if (bytes.length !== 32 && bytes.length !== 33)
    throw "invalid pubkey length";
  bytes = bytes.length === 33 ? bytes.slice(1) : bytes;
  return new import_ed255193.Ed25519PublicKey(bytes);
}

// src/libs/multiSig/client.ts
var MultiSigClient = class _MultiSigClient {
  constructor(pks, threshold) {
    this.pksWeightPairs = pks;
    this.threshold = threshold;
    this.multiSigPublicKey = import_multisig.MultiSigPublicKey.fromPublicKeys({
      threshold: this.threshold,
      publicKeys: this.pksWeightPairs
    });
  }
  static fromRawEd25519PublicKeys(rawPublicKeys, weights, threshold) {
    const pks = rawPublicKeys.map((rawPublicKey, i) => {
      return {
        publicKey: ed25519PublicKeyFromBase64(rawPublicKey),
        weight: weights[i]
      };
    });
    return new _MultiSigClient(pks, threshold);
  }
  multiSigAddress() {
    return this.multiSigPublicKey.toSuiAddress();
  }
  combinePartialSigs(sigs) {
    return this.multiSigPublicKey.combinePartialSignatures(sigs);
  }
};

// src/metadata/index.ts
var import_client4 = require("@mysten/sui/client");
async function loadMetadata(networkType, packageId, fullnodeUrls) {
  fullnodeUrls = fullnodeUrls || [(0, import_client4.getFullnodeUrl)(networkType)];
  const suiInteractor = new SuiInteractor(fullnodeUrls);
  if (packageId !== void 0) {
    const jsonData = await suiInteractor.getNormalizedMoveModulesByPackage(
      packageId
    );
    return jsonData;
  } else {
    console.error("please set your package id.");
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  BcsType,
  Dubhe,
  MultiSigClient,
  SuiAccountManager,
  SuiContractFactory,
  SuiTx,
  bcs,
  loadMetadata,
  ...require("@mysten/sui/client"),
  ...require("@mysten/sui/utils"),
  ...require("@mysten/sui/transactions"),
  ...require("@mysten/sui/bcs"),
  ...require("@mysten/sui/keypairs/ed25519"),
  ...require("@mysten/sui/keypairs/secp256k1"),
  ...require("@mysten/sui/keypairs/secp256r1")
});
//# sourceMappingURL=index.js.map