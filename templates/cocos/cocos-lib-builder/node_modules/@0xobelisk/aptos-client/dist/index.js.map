{"version":3,"sources":["../src/index.ts","../src/dubhe.ts","../src/libs/aptosAccountManager/index.ts","../src/libs/aptosAccountManager/keypair.ts","../src/libs/aptosAccountManager/crypto.ts","../src/libs/aptosInteractor/aptosInteractor.ts","../src/libs/aptosInteractor/defaultConfig.ts","../src/types/index.ts","../src/libs/aptosInteractor/util.ts","../src/libs/aptosContractFactory/index.ts","../src/metadata/index.ts"],"sourcesContent":["export * from 'aptos';\nexport { Dubhe } from './dubhe';\nexport { AptosAccountManager } from './libs/aptosAccountManager';\nexport { AptosContractFactory } from './libs/aptosContractFactory';\nexport { AptosInteractor, getDefaultURL } from './libs/aptosInteractor';\nexport { loadMetadata } from './metadata';\nexport type * from './types';\n","import {\n  Types,\n  TxnBuilderTypes,\n  AptosAccount,\n  Network,\n  HexString,\n} from 'aptos';\nimport { AptosAccountManager } from './libs/aptosAccountManager';\n// import { SuiTxBlock } from './libs/suiTxBuilder';\nimport { AptosInteractor, getDefaultURL } from './libs/aptosInteractor';\n// import { SuiSharedObject, SuiOwnedObject } from './libs/suiModel';\n\nimport { AptosContractFactory } from './libs/aptosContractFactory';\nimport {\n  MoveModuleValueType,\n  MoveModuleFuncType,\n} from './libs/aptosContractFactory/types';\n\nimport {\n  DubheParams,\n  DerivePathParams,\n  ComponentContentType,\n  ContractQuery,\n  ContractTx,\n  MapModuleFuncQuery,\n  MapModuleFuncTx,\n  NetworkType,\n} from './types';\n\nconst {\n  AccountAddress,\n  EntryFunction,\n  MultiSig,\n  MultiSigTransactionPayload,\n  TransactionPayloadMultisig,\n} = TxnBuilderTypes;\n\ntype RawTransaction = TxnBuilderTypes.RawTransaction;\n\nexport function isUndefined(value?: unknown): value is undefined {\n  return value === undefined;\n}\n\nexport function withMeta<T extends { meta: MoveModuleFuncType }>(\n  meta: MoveModuleFuncType,\n  creator: Omit<T, 'meta'>\n): T {\n  (creator as T).meta = meta;\n\n  return creator as T;\n}\n\nfunction createQuery(\n  meta: MoveModuleFuncType,\n  fn: (\n    params?: any[],\n    typeArguments?: Types.MoveType[]\n  ) => Promise<Types.MoveValue[]>\n): ContractQuery {\n  return withMeta(\n    meta,\n    async (\n      params?: any[],\n      typeArguments?: Types.MoveType[]\n    ): Promise<Types.MoveValue[]> => {\n      const result = await fn(params, typeArguments);\n      return result;\n    }\n  );\n}\n\nfunction createTx(\n  meta: MoveModuleFuncType,\n  fn: (\n    sender?: HexString | string,\n    params?: any[],\n    typeArguments?: Types.MoveType[],\n    isRaw?: boolean\n  ) => Promise<Types.PendingTransaction | Types.EntryFunctionPayload>\n): ContractTx {\n  return withMeta(\n    meta,\n    async (\n      sender?: HexString | string,\n      params?: any[],\n      typeArguments?: Types.MoveType[],\n      isRaw?: boolean\n    ): Promise<Types.PendingTransaction | Types.EntryFunctionPayload> => {\n      const result = await fn(sender, params, typeArguments, isRaw);\n      return result;\n    }\n  );\n}\n\n/**\n * @class Dubhe\n * @description This class is used to aggregate the tools that used to interact with SUI network.\n */\nexport class Dubhe {\n  public accountManager: AptosAccountManager;\n  public aptosInteractor: AptosInteractor;\n  public contractFactory: AptosContractFactory;\n  public packageId: string | undefined;\n  public metadata: Types.MoveModule[] | undefined;\n\n  readonly #query: MapModuleFuncQuery = {};\n  readonly #tx: MapModuleFuncTx = {};\n  /**\n   * Support the following ways to init the DubheClient:\n   * 1. mnemonics\n   * 2. secretKey (base64 or hex)\n   * If none of them is provided, will generate a random mnemonics with 24 words.\n   *\n   * @param mnemonics, 12 or 24 mnemonics words, separated by space\n   * @param secretKey, base64 or hex string, when mnemonics is provided, secretKey will be ignored\n   * @param networkType, 'testnet' | 'mainnet' | 'devnet' | 'localnet', default is 'devnet'\n   * @param fullnodeUrl, the fullnode url, default is the preconfig fullnode url for the given network type\n   * @param packageId\n   */\n  constructor({\n    mnemonics,\n    secretKey,\n    networkType,\n    fullnodeUrls,\n    packageId,\n    metadata,\n  }: DubheParams = {}) {\n    // Init the account manager\n    this.accountManager = new AptosAccountManager({ mnemonics, secretKey });\n    // Init the rpc provider\n    fullnodeUrls = fullnodeUrls || [getDefaultURL(networkType).fullNode];\n    this.aptosInteractor = new AptosInteractor(fullnodeUrls, networkType);\n\n    this.packageId = packageId;\n    if (metadata !== undefined) {\n      this.metadata = metadata as Types.MoveModule[];\n      Object.values(metadata as Types.MoveModule[]).forEach((metadataRes) => {\n        let contractAddress = metadataRes.address;\n        let moduleName = metadataRes.name;\n        Object.values(metadataRes.exposed_functions).forEach((value) => {\n          const meta: MoveModuleFuncType = {\n            contractAddress,\n            moduleName,\n            funcName: value.name,\n            visibility: value.visibility,\n            isEntry: value.is_entry,\n            isView: value.is_view,\n            typeParameters: value.generic_type_params,\n            parameters: value.params,\n            return: value.return,\n          };\n\n          if (value.is_view) {\n            if (isUndefined(this.#query[moduleName])) {\n              this.#query[moduleName] = {};\n            }\n            if (isUndefined(this.#query[moduleName][value.name])) {\n              this.#query[moduleName][value.name] = createQuery(\n                meta,\n                (p, type_p) => this.#read(meta, p, type_p)\n              );\n            }\n          }\n\n          if (value.is_entry) {\n            if (isUndefined(this.#tx[moduleName])) {\n              this.#tx[moduleName] = {};\n            }\n            if (isUndefined(this.#tx[moduleName][value.name])) {\n              this.#tx[moduleName][value.name] = createTx(\n                meta,\n                (s, p, type_p, isRaw) => this.#exec(meta, s, p, type_p, isRaw)\n              );\n            }\n          }\n        });\n      });\n    }\n    this.contractFactory = new AptosContractFactory({\n      packageId,\n      metadata,\n    });\n  }\n\n  public get query(): MapModuleFuncQuery {\n    return this.#query;\n  }\n\n  public get tx(): MapModuleFuncTx {\n    return this.#tx;\n  }\n\n  #exec = async (\n    meta: MoveModuleFuncType,\n    sender?: HexString | string,\n    params?: any[],\n    typeArguments?: Types.MoveType[],\n    isRaw?: boolean\n  ) => {\n    if (typeArguments === undefined) {\n      typeArguments = [];\n    }\n\n    if (params === undefined) {\n      params = [];\n    }\n\n    const payload = await this.generatePayload(\n      `${this.contractFactory.packageId}::${meta.moduleName}::${meta.funcName}`,\n      typeArguments,\n      params\n    );\n\n    if (isRaw === true) {\n      return payload;\n    }\n    return await this.signAndSendTxnWithPayload(payload, sender);\n  };\n\n  #read = async (\n    meta: MoveModuleFuncType,\n    params?: any[],\n    typeArguments?: Types.MoveType[]\n  ) => {\n    if (typeArguments === undefined) {\n      typeArguments = [];\n    }\n\n    if (params === undefined) {\n      params = [];\n    }\n\n    return this.aptosInteractor.view(\n      meta.contractAddress,\n      meta.moduleName,\n      meta.funcName,\n      typeArguments,\n      params\n    );\n  };\n  /**\n   * if derivePathParams is not provided or mnemonics is empty, it will return the currentSigner.\n   * else:\n   * it will generate signer from the mnemonic with the given derivePathParams.\n   * @param derivePathParams, such as { accountIndex: 2, isExternal: false, addressIndex: 10 }, comply with the BIP44 standard\n   */\n  getSigner(derivePathParams?: DerivePathParams) {\n    const keyPair = this.accountManager.getKeyPair(derivePathParams);\n    return keyPair;\n  }\n\n  /**\n   * @description Switch the current account with the given derivePathParams\n   * @param derivePathParams, such as { accountIndex: 2, isExternal: false, addressIndex: 10 }, comply with the BIP44 standard\n   */\n  switchAccount(derivePathParams: DerivePathParams) {\n    this.accountManager.switchAccount(derivePathParams);\n  }\n\n  /**\n   * @description Get the address of the account for the given derivePathParams\n   * @param derivePathParams, such as { accountIndex: 2, isExternal: false, addressIndex: 10 }, comply with the BIP44 standard\n   */\n  getAddress(derivePathParams?: DerivePathParams) {\n    return this.accountManager.getAddress(derivePathParams);\n  }\n  currentAddress() {\n    return this.accountManager.currentAddress;\n  }\n\n  provider() {\n    return this.aptosInteractor.currentProvider;\n  }\n\n  getPackageId() {\n    return this.contractFactory.packageId;\n  }\n\n  getMetadata(): Types.MoveModule[] | undefined {\n    return this.contractFactory.metadata;\n  }\n\n  /**\n   * Request some APT from faucet\n   * @Returns {Promise<boolean>}, true if the request is successful, false otherwise.\n   */\n  async requestFaucet(\n    network: NetworkType,\n    accountAddress?: string,\n    amount?: number\n  ) {\n    if (network === Network.MAINNET) {\n      return false;\n    }\n    if (accountAddress === undefined) {\n      accountAddress = this.getAddress();\n    }\n    if (amount === undefined) {\n      amount = 50000000;\n    }\n    return this.aptosInteractor.requestFaucet(network, accountAddress, amount);\n  }\n\n  async getBalance(\n    accountAddress?: string,\n    coinType?: string\n  ): Promise<string | number> {\n    try {\n      if (accountAddress === undefined) {\n        accountAddress = this.getAddress();\n      }\n      if (coinType === undefined) {\n        coinType = '0x1::aptos_coin::AptosCoin';\n      }\n\n      const resource = await this.aptosInteractor.getAccountResource(\n        accountAddress,\n        `0x1::coin::CoinStore<${coinType}>`\n      );\n\n      return parseInt((resource.data as any)['coin']['value']);\n    } catch (_) {\n      return 0;\n    }\n  }\n\n  async signAndSendTxnWithPayload(\n    payload: Types.EntryFunctionPayload,\n    sender?: HexString | string,\n    derivePathParams?: DerivePathParams\n  ) {\n    const signer = this.getSigner(derivePathParams);\n    if (sender === undefined) {\n      sender = signer.address();\n    }\n\n    if (typeof sender === 'string') {\n      sender = new HexString(sender);\n    }\n\n    return this.aptosInteractor.sendTxWithPayload(signer, sender, payload);\n  }\n\n  async generatePayload(\n    target: string,\n    typeArguments: Types.MoveType[],\n    params: any[]\n  ): Promise<Types.EntryFunctionPayload> {\n    const payload = {\n      function: target, // `${contractAddress}::${moduleName}::${funcName}`\n      type_arguments: typeArguments,\n      arguments: params,\n    };\n    return payload;\n  }\n\n  async generateTransaction(\n    sender: HexString,\n    contractAddress: string,\n    moduleName: string,\n    funcName: string,\n    typeArguments: Types.MoveType[],\n    params: any[]\n  ): Promise<RawTransaction> {\n    const rawTxn = await this.aptosInteractor.currentClient.generateTransaction(\n      sender,\n      {\n        function: `${contractAddress}::${moduleName}::${funcName}`,\n        type_arguments: typeArguments,\n        arguments: params,\n      }\n    );\n    return rawTxn;\n  }\n\n  async waitForTransaction(txnHash: string) {\n    return this.aptosInteractor.waitForTransaction(txnHash);\n  }\n\n  async signAndSendTxn(\n    tx: RawTransaction,\n    derivePathParams?: DerivePathParams\n  ) {\n    const sender = this.getSigner(derivePathParams);\n    return this.aptosInteractor.signAndSubmitTransaction(sender, tx);\n  }\n\n  async getEntity(\n    schemaName: string,\n    entityId?: string\n  ): Promise<any[] | undefined> {\n    const schemaModuleName = `${schemaName}_schema`;\n    let params = [];\n    if (entityId !== undefined) {\n      params.push(entityId);\n    }\n\n    const result = await this.query[schemaModuleName].get(undefined, params);\n    return result;\n  }\n\n  async containEntity(\n    schemaName: string,\n    entityId?: string\n  ): Promise<boolean | undefined> {\n    const schemaModuleName = `${schemaName}_schema`;\n    let params = [];\n    if (entityId !== undefined) {\n      params.push(entityId);\n    }\n\n    const result = await this.query[schemaModuleName].contains(\n      undefined,\n      params\n    );\n    return result[0] as boolean;\n  }\n}\n","import { AptosAccount, AptosAccountObject } from 'aptos';\nimport { getKeyPair } from './keypair';\nimport { generateMnemonic } from './crypto';\nimport type { AccountMangerParams, DerivePathParams } from '../../types';\n\nexport class AptosAccountManager {\n  private mnemonics: string;\n  private secretKey: string;\n  public currentKeyPair: AptosAccount;\n  public currentAddress: string;\n\n  /**\n   * Support the following ways to init the SuiToolkit:\n   * 1. mnemonics\n   * 2. secretKey (base64 or hex)\n   * If none of them is provided, will generate a random mnemonics with 24 words.\n   *\n   * @param mnemonics, 12 or 24 mnemonics words, separated by space\n   * @param secretKey, base64 or hex string, when mnemonics is provided, secretKey will be ignored\n   */\n  constructor({ mnemonics, secretKey }: AccountMangerParams = {}) {\n    // If the mnemonics or secretKey is provided, use it\n    // Otherwise, generate a random mnemonics with 24 words\n    this.mnemonics = mnemonics || '';\n    this.secretKey = secretKey || '';\n    if (!this.mnemonics && !this.secretKey) {\n      this.mnemonics = generateMnemonic(24);\n    }\n\n    // Init the current account\n    /**\n     * {\n     *    address: \"0xe8012714cd17606cee7188a2a365eef3fe760be598750678c8c5954eb548a591\",\n     *    publicKeyHex: \"0xf56d8524faf79fbc0f48c13aeed3b0ce5dd376b4db93b8130a107c0a5e04ba04\",\n     *    privateKeyHex: `0x009c9f7c992a06cfafe916f125d8adb7a395fca243e264a8e56a4b3e6accf940\n     *      d2b11e9ece3049ce60e3c7b4a1c58aebfa9298e29a30a58a67f1998646135204`\n     *  }\n     */\n    this.currentKeyPair = this.secretKey\n      ? AptosAccount.fromAptosAccountObject({\n          privateKeyHex: secretKey!,\n        })\n      : getKeyPair(this.mnemonics);\n\n    this.currentAddress = this.currentKeyPair.address().toString();\n  }\n\n  /**\n   * if derivePathParams is not provided or mnemonics is empty, it will return the currentKeyPair.\n   * else:\n   * it will generate keyPair from the mnemonic with the given derivePathParams.\n   */\n  getKeyPair(derivePathParams?: DerivePathParams) {\n    if (!derivePathParams || !this.mnemonics) return this.currentKeyPair;\n    return getKeyPair(this.mnemonics, derivePathParams);\n  }\n\n  /**\n   * if derivePathParams is not provided or mnemonics is empty, it will return the currentAddress.\n   * else:\n   * it will generate address from the mnemonic with the given derivePathParams.\n   */\n  getAddress(derivePathParams?: DerivePathParams) {\n    if (!derivePathParams || !this.mnemonics) return this.currentAddress;\n    return getKeyPair(this.mnemonics, derivePathParams).address().toString();\n  }\n\n  /**\n   * Switch the current account with the given derivePathParams.\n   * This is only useful when the mnemonics is provided. For secretKey mode, it will always use the same account.\n   */\n  switchAccount(derivePathParams: DerivePathParams) {\n    if (this.mnemonics) {\n      this.currentKeyPair = getKeyPair(this.mnemonics, derivePathParams);\n      this.currentAddress = this.currentKeyPair.address().toString();\n    }\n  }\n}\n","import { AptosAccount } from 'aptos';\nimport type { DerivePathParams } from '../../types';\n\n/**\n * @description Get ed25519 derive path for APTOS\n * @param derivePathParams\n */\nexport const getDerivePathForAPTOS = (\n  derivePathParams: DerivePathParams = {}\n) => {\n  const {\n    accountIndex = 0,\n    isExternal = false,\n    addressIndex = 0,\n  } = derivePathParams;\n  return `m/44'/637'/${accountIndex}'/${isExternal ? 1 : 0}'/${addressIndex}'`;\n};\n\n/**\n * the format is m/44'/784'/accountIndex'/${isExternal ? 1 : 0}'/addressIndex'\n *\n * accountIndex is the index of the account, default is 0.\n *\n * isExternal is the type of the address, default is false. Usually, the external address is used to receive coins. The internal address is used to change coins.\n *\n * addressIndex is the index of the address, default is 0. It's used to generate multiple addresses for one account.\n *\n * @description Get keypair from mnemonics and derive path\n * @param mnemonics\n * @param derivePathParams\n */\nexport const getKeyPair = (\n  mnemonics: string,\n  derivePathParams: DerivePathParams = {}\n) => {\n  const derivePath = getDerivePathForAPTOS(derivePathParams);\n  return AptosAccount.fromDerivePath(derivePath, mnemonics);\n};\n","import { generateMnemonic as genMnemonic } from '@scure/bip39';\nimport { wordlist } from '@scure/bip39/wordlists/english';\n\nexport const generateMnemonic = (numberOfWords: 12 | 24 = 24) => {\n  const strength = numberOfWords === 12 ? 128 : 256;\n  return genMnemonic(wordlist, strength);\n};\n","import {\n  Provider,\n  FaucetClient,\n  TxnBuilderTypes,\n  AptosAccount,\n  AptosClient,\n  IndexerClient,\n  Network,\n  Types,\n  HexString,\n} from 'aptos';\nimport { getDefaultURL } from './defaultConfig';\nimport { delay } from './util';\nimport {\n  MovementNetwork,\n  NetworkType,\n  NetworkNameToIndexerAPI,\n} from 'src/types';\nconst {\n  AccountAddress,\n  EntryFunction,\n  MultiSig,\n  MultiSigTransactionPayload,\n  TransactionPayloadMultisig,\n} = TxnBuilderTypes;\n\ntype RawTransaction = TxnBuilderTypes.RawTransaction;\n\n/**\n * `SuiTransactionSender` is used to send transaction with a given gas coin.\n * It always uses the gas coin to pay for the gas,\n * and update the gas coin after the transaction.\n */\nexport class AptosInteractor {\n  public readonly providers: Provider[];\n  public currentProvider: Provider;\n  public currentClient: AptosClient;\n  public network?: NetworkType;\n  public indexerClient?: IndexerClient;\n\n  constructor(fullNodeUrls: string[], network?: NetworkType) {\n    if (fullNodeUrls.length === 0)\n      throw new Error('fullNodeUrls must not be empty');\n    this.providers = fullNodeUrls.map(\n      (url) => new Provider({ fullnodeUrl: url, indexerUrl: url })\n    );\n    this.currentProvider = this.providers[0];\n    this.currentClient = new AptosClient(fullNodeUrls[0]);\n\n    this.network = network;\n\n    // if (Object.values(MovementNetwork).includes(network as MovementNetwork)) {\n    // } else if (Object.values(Network).includes(network as Network)) {\n    // }\n    if (\n      network !== undefined &&\n      network !== Network.LOCAL &&\n      network !== MovementNetwork.LOCAL\n    ) {\n      this.indexerClient = new IndexerClient(NetworkNameToIndexerAPI[network]);\n    }\n  }\n\n  switchToNextProvider() {\n    const currentProviderIdx = this.providers.indexOf(this.currentProvider);\n    this.currentProvider =\n      this.providers[(currentProviderIdx + 1) % this.providers.length];\n  }\n\n  async signTransaction(sender: AptosAccount, rawTxn: RawTransaction) {\n    try {\n      const signedBcsTxn = await this.currentProvider.signTransaction(\n        sender,\n        rawTxn\n      );\n      return signedBcsTxn;\n    } catch (err) {\n      console.warn(`Failed to sign transaction: ${err}`);\n      await delay(2000);\n    }\n  }\n\n  async submitTransaction(signedTxn: Uint8Array) {\n    try {\n      const pendingTxn = await this.currentProvider.submitTransaction(\n        signedTxn\n      );\n      return pendingTxn;\n    } catch (err) {\n      console.warn(`Failed to submit transaction: ${err}`);\n      await delay(2000);\n    }\n  }\n\n  async waitForTransaction(txnHash: string) {\n    try {\n      await this.currentProvider.waitForTransaction(txnHash, {\n        checkSuccess: true,\n      });\n      return txnHash;\n    } catch (err) {\n      console.warn(`Failed to sign transaction: ${err}`);\n      await delay(2000);\n    }\n  }\n\n  async sendTxWithPayload(\n    signer: AptosAccount,\n    sender: HexString,\n    payload: Types.EntryFunctionPayload\n  ): Promise<Types.PendingTransaction> {\n    for (const provider of this.providers) {\n      try {\n        const rawTxn = await provider.generateTransaction(sender, payload);\n        const bcsTxn = AptosClient.generateBCSTransaction(signer, rawTxn);\n        const txnHash = await provider.submitSignedBCSTransaction(bcsTxn);\n        return txnHash;\n      } catch (err) {\n        console.warn(\n          `Failed to send transaction with fullnode ${provider.nodeUrl}: ${err}`\n        );\n        await delay(2000);\n      }\n    }\n    throw new Error('Failed to send transaction with all fullnodes');\n  }\n\n  async signAndSubmitTransaction(\n    sender: AptosAccount,\n    rawTransaction: RawTransaction\n  ): Promise<any> {\n    for (const provider of this.providers) {\n      try {\n        const txnHash = await provider.signAndSubmitTransaction(\n          sender,\n          rawTransaction\n        );\n        return txnHash;\n      } catch (err) {\n        console.warn(\n          `Failed to send transaction with fullnode ${provider.nodeUrl}: ${err}`\n        );\n        await delay(2000);\n      }\n    }\n    throw new Error('Failed to send transaction with all fullnodes');\n  }\n\n  async getAccountResources(accountAddress: string) {\n    for (const provider of this.providers) {\n      try {\n        return provider.getAccountResources(accountAddress);\n      } catch (err) {\n        await delay(2000);\n        console.warn(\n          `Failed to get AccountResources with fullnode ${provider.nodeUrl}: ${err}`\n        );\n      }\n    }\n    throw new Error('Failed to get AccountResources with all fullnodes');\n  }\n\n  async getAccountResource(\n    accountAddress: string,\n    resourceType: Types.MoveStructTag,\n    ledgerVersion?: number\n  ) {\n    for (const provider of this.providers) {\n      try {\n        let ledgerVersionBig;\n        if (ledgerVersion !== undefined) {\n          ledgerVersionBig = BigInt(ledgerVersion);\n        }\n        return provider.getAccountResource(accountAddress, resourceType, {\n          ledgerVersion: ledgerVersionBig,\n        });\n      } catch (err) {\n        await delay(2000);\n        console.warn(\n          `Failed to get AccountResource with fullnode ${provider.nodeUrl}: ${err}`\n        );\n      }\n    }\n    throw new Error('Failed to get AccountResource with all fullnodes');\n  }\n\n  async getAccountModule(\n    accountAddress: string,\n    moduleName: string,\n    ledgerVersion?: number\n  ): Promise<Types.MoveModuleBytecode> {\n    for (const provider of this.providers) {\n      try {\n        let ledgerVersionBig;\n        if (ledgerVersion !== undefined) {\n          ledgerVersionBig = BigInt(ledgerVersion);\n        }\n        return provider.getAccountModule(accountAddress, moduleName, {\n          ledgerVersion: ledgerVersionBig,\n        });\n      } catch (err) {\n        await delay(2000);\n        console.warn(\n          `Failed to get AccountModule with fullnode ${provider.nodeUrl}: ${err}`\n        );\n      }\n    }\n    throw new Error('Failed to get AccountModule with all fullnodes');\n  }\n\n  async getAccountModules(\n    accountAddress: string\n  ): Promise<Types.MoveModuleBytecode[]> {\n    for (const provider of this.providers) {\n      try {\n        return provider.getAccountModules(accountAddress);\n      } catch (err) {\n        await delay(2000);\n        console.warn(\n          `Failed to get AccountModules with fullnode ${provider.nodeUrl}: ${err}`\n        );\n      }\n    }\n    throw new Error('Failed to get AccountModules with all fullnodes');\n  }\n\n  async view(\n    contractAddress: string,\n    moduleName: string,\n    funcName: string,\n    typeArguments: Types.MoveType[] = [],\n    args: any[] = []\n  ): Promise<Types.MoveValue[]> {\n    for (const provider of this.providers) {\n      try {\n        let request: Types.ViewRequest = {\n          function: `${contractAddress}::${moduleName}::${funcName}`,\n          type_arguments: typeArguments,\n          arguments: args,\n        };\n        return provider.view(request);\n      } catch (err) {\n        await delay(2000);\n        console.warn(\n          `Failed to view with fullnode ${provider.nodeUrl}: ${err}`\n        );\n      }\n    }\n    throw new Error('Failed to view with all fullnodes');\n  }\n\n  // /**\n  //  * @description Update objects in a batch\n  //  * @param suiObjects\n  //  */\n  // async updateObjects(suiObjects: (SuiOwnedObject | SuiSharedObject)[]) {\n  //   const objectIds = suiObjects.map((obj) => obj.objectId);\n  //   const objects = await this.getObjects(objectIds);\n  //   for (const object of objects) {\n  //     const suiObject = suiObjects.find(\n  //       (obj) => obj.objectId === object.objectId\n  //     );\n  //     if (suiObject instanceof SuiSharedObject) {\n  //       suiObject.initialSharedVersion = object.initialSharedVersion;\n  //     } else if (suiObject instanceof SuiOwnedObject) {\n  //       suiObject.version = object.objectVersion;\n  //       suiObject.digest = object.objectDigest;\n  //     }\n  //   }\n  // }\n\n  // /**\n  //  * @description Select coins that add up to the given amount.\n  //  * @param addr the address of the owner\n  //  * @param amount the amount that is needed for the coin\n  //  * @param coinType the coin type, default is '0x2::SUI::SUI'\n  //  */\n  // async selectCoins(\n  //   addr: string,\n  //   amount: number,\n  //   coinType: string = '0x2::SUI::SUI'\n  // ) {\n  //   const selectedCoins: {\n  //     objectId: string;\n  //     digest: string;\n  //     version: string;\n  //   }[] = [];\n  //   let totalAmount = 0;\n  //   let hasNext = true,\n  //     nextCursor: string | null = null;\n  //   while (hasNext && totalAmount < amount) {\n  //     const coins = await this.currentProvider.getCoins({\n  //       owner: addr,\n  //       coinType: coinType,\n  //       cursor: nextCursor,\n  //     });\n  //     // Sort the coins by balance in descending order\n  //     coins.data.sort((a, b) => parseInt(b.balance) - parseInt(a.balance));\n  //     for (const coinData of coins.data) {\n  //       selectedCoins.push({\n  //         objectId: coinData.coinObjectId,\n  //         digest: coinData.digest,\n  //         version: coinData.version,\n  //       });\n  //       totalAmount = totalAmount + parseInt(coinData.balance);\n  //       if (totalAmount >= amount) {\n  //         break;\n  //       }\n  //     }\n\n  //     nextCursor = coins.nextCursor;\n  //     hasNext = coins.hasNextPage;\n  //   }\n\n  //   if (!selectedCoins.length) {\n  //     throw new Error('No valid coins found for the transaction.');\n  //   }\n  //   return selectedCoins;\n  // }\n\n  async requestFaucet(\n    network: NetworkType,\n    accountAddress: string,\n    amount: number\n  ) {\n    const defaultUrl = getDefaultURL(network);\n    if (defaultUrl.faucet === undefined) {\n      return false;\n    }\n\n    try {\n      const faucetClient = new FaucetClient(\n        defaultUrl.fullNode,\n        defaultUrl.faucet\n      );\n\n      await faucetClient.fundAccount(accountAddress, amount);\n      return true;\n    } catch (err) {\n      console.warn(`Failed to fund token with faucetClient: ${err}`);\n    }\n    return false;\n  }\n}\n","import { Network, Provider } from 'aptos';\nimport { MovementNetwork, NetworkType } from 'src/types';\nexport const defaultGasBudget = 10 ** 8; // 0.1 APTOS, should be enough for most of the transactions\nexport const defaultGasPrice = 1000; // 1000 MIST\n\n/**\n//  * @description Get the default fullnode url for the given network type\n//  * @param networkType, 'testnet' | 'mainnet' | 'devnet' | 'localnet', default is 'devnet'\n//  * @returns { fullNode: string }\n//  */\n// export const getDefaultURL = (networkType: NetworkType = Network.DEVNET) => {\n//   switch (networkType) {\n//     case Network.LOCAL:\n//       return 'http://127.0.0.1:8080';\n//     case Network.DEVNET:\n//       return 'https://fullnode.devnet.aptoslabs.com';\n//     case Network.TESTNET:\n//       return 'https://fullnode.testnet.aptoslabs.com';\n//     case Network.MAINNET:\n//       return 'https://fullnode.mainnet.aptoslabs.com';\n//     default:\n//       return 'https://fullnode.devnet.aptoslabs.com';\n//   }\n// };\n\n/**\n * @description Get the default fullnode and faucet url for the given network type\n * @param networkType, 'testnet' | 'mainnet' | 'devnet' | 'localnet', default is 'devnet'\n * @returns { fullNode: string, faucet?: string }\n */\nexport const getDefaultURL = (networkType: NetworkType = Network.DEVNET) => {\n  switch (networkType) {\n    case Network.LOCAL:\n      return {\n        fullNode: 'http://127.0.0.1:8080',\n        faucet: 'http://127.0.0.1:8081',\n      };\n    case Network.DEVNET:\n      return {\n        fullNode: 'https://fullnode.devnet.aptoslabs.com',\n        faucet: 'https://faucet.devnet.aptoslabs.com',\n      };\n    case Network.TESTNET:\n      return {\n        fullNode: 'https://fullnode.testnet.aptoslabs.com',\n        faucet: 'https://faucet.testnet.aptoslabs.com',\n      };\n    case Network.MAINNET:\n      return {\n        fullNode: 'https://fullnode.mainnet.aptoslabs.com',\n      };\n    case MovementNetwork.DEVNET:\n      return {\n        fullNode: 'https://aptos.devnet.m1.movementlabs.xyz',\n        faucet: 'https://aptos.devnet.m1.movementlabs.xyz',\n      };\n    case MovementNetwork.TESTNET:\n      return {\n        fullNode: 'https://aptos.testnet.m1.movementlabs.xyz',\n        faucet: 'https://aptos.testnet.m1.movementlabs.xyz',\n      };\n    default:\n      return {\n        fullNode: 'https://fullnode.devnet.aptoslabs.com',\n        faucet: 'https://faucet.devnet.aptoslabs.com',\n      };\n  }\n};\n","import { HexString, Network, Types } from 'aptos';\n\nimport { MoveModuleFuncType } from '../libs/aptosContractFactory/types';\n\nexport type DubheParams = {\n  mnemonics?: string;\n  secretKey?: string;\n  fullnodeUrls?: string[];\n  faucetUrl?: string;\n  networkType?: NetworkType;\n  packageId?: string;\n  metadata?: Types.MoveModule[];\n};\n\nexport type ComponentFieldType = {\n  components: {\n    type: string;\n    fields: {\n      id: {\n        id: string;\n      };\n      size: string;\n    };\n  };\n};\n\nexport type ComponentValueType = {\n  id: {\n    id: string;\n  };\n  name: string;\n  value: {\n    type: string;\n    fields: ComponentFieldType;\n  };\n};\n\nexport type ComponentContentType = {\n  type: string;\n  fields: ComponentValueType;\n  hasPublicTransfer: boolean;\n  dataType: 'moveObject';\n};\n\nexport interface MessageMeta {\n  readonly meta: MoveModuleFuncType;\n}\n\nexport interface ContractQuery extends MessageMeta {\n  (params?: any[], typeArguments?: Types.MoveType[]): Promise<\n    Types.MoveValue[]\n  >;\n}\n\nexport interface ContractTx extends MessageMeta {\n  (\n    sender?: HexString | string,\n    params?: any[],\n    typeArguments?: Types.MoveType[],\n    isRaw?: boolean\n  ): Promise<Types.PendingTransaction | Types.EntryFunctionPayload>;\n}\n\nexport type MapMessageTx = Record<string, ContractTx>;\nexport type MapMessageQuery = Record<string, ContractQuery>;\n\nexport type MapModuleFuncTx = Record<string, MapMessageTx>;\nexport type MapModuleFuncQuery = Record<string, MapMessageQuery>;\n\nexport type MapModuleFuncTest = Record<string, Record<string, string>>;\nexport type MapModuleFuncQueryTest = Record<string, Record<string, string>>;\n\nexport type AccountMangerParams = {\n  mnemonics?: string;\n  secretKey?: string;\n};\n\nexport type DerivePathParams = {\n  accountIndex?: number;\n  isExternal?: boolean;\n  addressIndex?: number;\n};\n\nexport enum MovementNetwork {\n  // MAINNET = \"movementmainnet\",\n  TESTNET = 'movementtestnet',\n  DEVNET = 'movementdevnet',\n  LOCAL = 'movementlocal',\n}\n\nexport const NetworkNameToIndexerAPI: Record<string, string> = {\n  mainnet: 'https://api.mainnet.aptoslabs.com/v1/graphql',\n  testnet: 'https://api.testnet.aptoslabs.com/v1/graphql',\n  devnet: 'https://api.devnet.aptoslabs.com/v1/graphql',\n  local: 'http://127.0.0.1:8090/v1/graphql',\n  movementmainnet: '',\n  movementtestnet: '',\n  movementdevnet: '',\n  movementlocal: '',\n};\n\nexport type NetworkType = Network | MovementNetwork;\n\nexport type InputNetworkType =\n  | 'mainnet'\n  | 'testnet'\n  | 'devnet'\n  | 'local'\n  | 'movementtestnet'\n  | 'movementdevnet'\n  | 'movementlocal';\n\n/**\n * These are the basics types that can be used in the APT\n */\nexport type MoveBasicTypes =\n  | 'address'\n  | 'bool'\n  | 'u8'\n  | 'u16'\n  | 'u32'\n  | 'u64'\n  | 'u128'\n  | 'u256';\n\nexport type MoveInputTypes = 'object' | MoveBasicTypes;\n","export const delay = (ms: number) =>\n  new Promise((resolve) => setTimeout(resolve, ms));\n","import { Types } from 'aptos';\nimport type { ContractFactoryParams } from './types';\nexport type ApiTypes = 'promise' | 'rxjs';\n\nexport class AptosContractFactory {\n  public packageId: string;\n  public metadata: Types.MoveModule[] | undefined;\n  // readonly #query: MapMessageQuery<ApiTypes> = {};\n  // readonly #tx: MapMessageTx<ApiTypes> = {};\n  /**\n   * Support the following ways to init the Aptos Dubhe:\n   * 1. mnemonics\n   * 2. secretKey (base64 or hex)\n   * If none of them is provided, will generate a random mnemonics with 24 words.\n   *\n   * @param mnemonics, 12 or 24 mnemonics words, separated by space\n   * @param secretKey, base64 or hex string, when mnemonics is provided, secretKey will be ignored\n   */\n  constructor({ packageId, metadata }: ContractFactoryParams = {}) {\n    // If the mnemonics or secretKey is provided, use it\n    // Otherwise, generate a random mnemonics with 24 words\n    this.packageId = packageId || '';\n    this.metadata = metadata || undefined;\n  }\n\n  // getFuncByModuleName(moduleName: string) {\n  //   Object.values(this.metadata as Types.MoveModule).forEach((value) => {\n  //     const data = value as SuiMoveMoudleValueType;\n  //     console.log(`moudle name: ${data.name}`);\n  //     // console.log(data.exposedFunctions)\n  //     Object.entries(data.exposedFunctions).forEach(([key, value]) => {\n  //       console.log(`\\tfunc name: ${key}`);\n  //       Object.values(value.parameters).forEach((values) => {\n  //         // console.log(values)\n  //       });\n  //     });\n  //   });\n  // }\n\n  // getAllFunc() {\n  //   Object.values(this.metadata as SuiMoveNormalizedModules).forEach(\n  //     (value) => {\n  //       const data = value as SuiMoveMoudleValueType;\n  //       console.log(`moudle name: ${data.name}`);\n  //       // console.log(data.exposedFunctions)\n  //       Object.entries(data.exposedFunctions).forEach(([key, value]) => {\n  //         console.log(`\\tfunc name: ${key}`);\n  //         console.log(`\\t\\t${value.parameters.length}`);\n  //         Object.values(value.parameters).forEach((values) => {\n  //           // console.log(values)\n  //           console.log(`\\t\\targs: ${values}`);\n  //         });\n  //       });\n  //     }\n  //   );\n  // }\n\n  // getAllModule() {\n  //   Object.values(this.metadata as SuiMoveNormalizedModules).forEach(\n  //     (value, index) => {\n  //       const data = value as SuiMoveMoudleValueType;\n  //       console.log(`${index}. ${data.name}`);\n  //     }\n  //   );\n  // }\n\n  //   async call(arguments: ({\n  //     kind: \"Input\";\n  //     index: number;\n  //     type?: \"object\" | \"pure\" | undefined;\n  //     value?: any;\n  // } | {\n  //     kind: \"GasCoin\";\n  // } | {\n  //     kind: \"Result\";\n  //     index: number;\n  // } | {\n  //     kind: \"NestedResult\";\n  //     index: number;\n  //     resultIndex: number;\n  // })[], derivePathParams?: DerivePathParams) {\n  //     const tx = new TransactionBlock();\n  //     tx.moveCall({\n  //       target: `${this.packageId}::${}::${}`,\n  //       arguments,\n  //     })\n  //     return ;\n  //   }\n}\n\n// function createTx <ApiType extends ApiTypes> (meta: AbiMessage, fn: (options: ContractOptions, params: unknown[]) => SubmittableExtrinsic<ApiType>): ContractTx<ApiType> {\n//   return withMeta(meta, (options: ContractOptions, ...params: unknown[]): SubmittableExtrinsic<ApiType> =>\n//     fn(options, params)\n//   );\n// }\n","import { Types } from 'aptos';\nimport { NetworkType } from '../types';\nimport { AptosInteractor, getDefaultURL } from '../libs/aptosInteractor';\n\nexport async function loadMetadata(\n  networkType: NetworkType,\n  packageId: string\n): Promise<Types.MoveModule[] | undefined> {\n  // Init the rpc provider\n  const fullnodeUrls = [getDefaultURL(networkType).fullNode];\n  const aptosInteractor = new AptosInteractor(fullnodeUrls);\n  if (packageId !== undefined) {\n    const jsonData = await aptosInteractor.getAccountModules(packageId);\n    return jsonData.map((data) => data.abi!);\n  } else {\n    console.error('please set your package id.');\n  }\n}\n"],"mappings":"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","names":["import_aptos","import_aptos","genMnemonic","import_aptos","import_aptos","AccountAddress","EntryFunction","MultiSig","MultiSigTransactionPayload","TransactionPayloadMultisig"]}