import { Types, TxnBuilderTypes, AptosAccount, HexString } from 'aptos';
import { AptosAccountManager } from './libs/aptosAccountManager';
import { AptosInteractor } from './libs/aptosInteractor';
import { AptosContractFactory } from './libs/aptosContractFactory';
import { MoveModuleFuncType } from './libs/aptosContractFactory/types';
import { DubheParams, DerivePathParams, MapModuleFuncQuery, MapModuleFuncTx, NetworkType } from './types';
type RawTransaction = TxnBuilderTypes.RawTransaction;
export declare function isUndefined(value?: unknown): value is undefined;
export declare function withMeta<T extends {
    meta: MoveModuleFuncType;
}>(meta: MoveModuleFuncType, creator: Omit<T, 'meta'>): T;
/**
 * @class Dubhe
 * @description This class is used to aggregate the tools that used to interact with SUI network.
 */
export declare class Dubhe {
    #private;
    accountManager: AptosAccountManager;
    aptosInteractor: AptosInteractor;
    contractFactory: AptosContractFactory;
    packageId: string | undefined;
    metadata: Types.MoveModule[] | undefined;
    /**
     * Support the following ways to init the DubheClient:
     * 1. mnemonics
     * 2. secretKey (base64 or hex)
     * If none of them is provided, will generate a random mnemonics with 24 words.
     *
     * @param mnemonics, 12 or 24 mnemonics words, separated by space
     * @param secretKey, base64 or hex string, when mnemonics is provided, secretKey will be ignored
     * @param networkType, 'testnet' | 'mainnet' | 'devnet' | 'localnet', default is 'devnet'
     * @param fullnodeUrl, the fullnode url, default is the preconfig fullnode url for the given network type
     * @param packageId
     */
    constructor({ mnemonics, secretKey, networkType, fullnodeUrls, packageId, metadata, }?: DubheParams);
    get query(): MapModuleFuncQuery;
    get tx(): MapModuleFuncTx;
    /**
     * if derivePathParams is not provided or mnemonics is empty, it will return the currentSigner.
     * else:
     * it will generate signer from the mnemonic with the given derivePathParams.
     * @param derivePathParams, such as { accountIndex: 2, isExternal: false, addressIndex: 10 }, comply with the BIP44 standard
     */
    getSigner(derivePathParams?: DerivePathParams): AptosAccount;
    /**
     * @description Switch the current account with the given derivePathParams
     * @param derivePathParams, such as { accountIndex: 2, isExternal: false, addressIndex: 10 }, comply with the BIP44 standard
     */
    switchAccount(derivePathParams: DerivePathParams): void;
    /**
     * @description Get the address of the account for the given derivePathParams
     * @param derivePathParams, such as { accountIndex: 2, isExternal: false, addressIndex: 10 }, comply with the BIP44 standard
     */
    getAddress(derivePathParams?: DerivePathParams): string;
    currentAddress(): string;
    provider(): import("aptos").Provider;
    getPackageId(): string;
    getMetadata(): Types.MoveModule[] | undefined;
    /**
     * Request some APT from faucet
     * @Returns {Promise<boolean>}, true if the request is successful, false otherwise.
     */
    requestFaucet(network: NetworkType, accountAddress?: string, amount?: number): Promise<boolean>;
    getBalance(accountAddress?: string, coinType?: string): Promise<string | number>;
    signAndSendTxnWithPayload(payload: Types.EntryFunctionPayload, sender?: HexString | string, derivePathParams?: DerivePathParams): Promise<{
        hash: string;
        sender: string;
        sequence_number: string;
        max_gas_amount: string;
        gas_unit_price: string;
        expiration_timestamp_secs: string;
        payload: Types.TransactionPayload;
        signature?: (({
            type: string;
        } & Types.Ed25519Signature) | ({
            type: string;
        } & Types.MultiEd25519Signature) | ({
            type: string;
        } & {
            sender: ({
                type: string;
            } & Types.Ed25519Signature) | ({
                type: string;
            } & Types.MultiEd25519Signature);
            secondary_signer_addresses: string[];
            secondary_signers: (({
                type: string;
            } & Types.Ed25519Signature) | ({
                type: string;
            } & Types.MultiEd25519Signature))[];
        }) | ({
            type: string;
        } & {
            sender: ({
                type: string;
            } & Types.Ed25519Signature) | ({
                type: string;
            } & Types.MultiEd25519Signature);
            secondary_signer_addresses: string[];
            secondary_signers: (({
                type: string;
            } & Types.Ed25519Signature) | ({
                type: string;
            } & Types.MultiEd25519Signature))[];
            fee_payer_address: string;
            fee_payer_signer: ({
                type: string;
            } & Types.Ed25519Signature) | ({
                type: string;
            } & Types.MultiEd25519Signature);
        })) | undefined;
    }>;
    generatePayload(target: string, typeArguments: Types.MoveType[], params: any[]): Promise<Types.EntryFunctionPayload>;
    generateTransaction(sender: HexString, contractAddress: string, moduleName: string, funcName: string, typeArguments: Types.MoveType[], params: any[]): Promise<RawTransaction>;
    waitForTransaction(txnHash: string): Promise<string | undefined>;
    signAndSendTxn(tx: RawTransaction, derivePathParams?: DerivePathParams): Promise<any>;
    getEntity(schemaName: string, entityId?: string): Promise<any[] | undefined>;
    containEntity(schemaName: string, entityId?: string): Promise<boolean | undefined>;
}
export {};
