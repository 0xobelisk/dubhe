var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};

// src/index.ts
export * from "aptos";

// src/dubhe.ts
import {
  TxnBuilderTypes as TxnBuilderTypes2,
  Network as Network3,
  HexString as HexString2
} from "aptos";

// src/libs/aptosAccountManager/index.ts
import { AptosAccount as AptosAccount2 } from "aptos";

// src/libs/aptosAccountManager/keypair.ts
import { AptosAccount } from "aptos";
var getDerivePathForAPTOS = (derivePathParams = {}) => {
  const {
    accountIndex = 0,
    isExternal = false,
    addressIndex = 0
  } = derivePathParams;
  return `m/44'/637'/${accountIndex}'/${isExternal ? 1 : 0}'/${addressIndex}'`;
};
var getKeyPair = (mnemonics, derivePathParams = {}) => {
  const derivePath = getDerivePathForAPTOS(derivePathParams);
  return AptosAccount.fromDerivePath(derivePath, mnemonics);
};

// src/libs/aptosAccountManager/crypto.ts
import { generateMnemonic as genMnemonic } from "@scure/bip39";
import { wordlist } from "@scure/bip39/wordlists/english";
var generateMnemonic = (numberOfWords = 24) => {
  const strength = numberOfWords === 12 ? 128 : 256;
  return genMnemonic(wordlist, strength);
};

// src/libs/aptosAccountManager/index.ts
var AptosAccountManager = class {
  /**
   * Support the following ways to init the SuiToolkit:
   * 1. mnemonics
   * 2. secretKey (base64 or hex)
   * If none of them is provided, will generate a random mnemonics with 24 words.
   *
   * @param mnemonics, 12 or 24 mnemonics words, separated by space
   * @param secretKey, base64 or hex string, when mnemonics is provided, secretKey will be ignored
   */
  constructor({ mnemonics, secretKey } = {}) {
    this.mnemonics = mnemonics || "";
    this.secretKey = secretKey || "";
    if (!this.mnemonics && !this.secretKey) {
      this.mnemonics = generateMnemonic(24);
    }
    this.currentKeyPair = this.secretKey ? AptosAccount2.fromAptosAccountObject({
      privateKeyHex: secretKey
    }) : getKeyPair(this.mnemonics);
    this.currentAddress = this.currentKeyPair.address().toString();
  }
  /**
   * if derivePathParams is not provided or mnemonics is empty, it will return the currentKeyPair.
   * else:
   * it will generate keyPair from the mnemonic with the given derivePathParams.
   */
  getKeyPair(derivePathParams) {
    if (!derivePathParams || !this.mnemonics)
      return this.currentKeyPair;
    return getKeyPair(this.mnemonics, derivePathParams);
  }
  /**
   * if derivePathParams is not provided or mnemonics is empty, it will return the currentAddress.
   * else:
   * it will generate address from the mnemonic with the given derivePathParams.
   */
  getAddress(derivePathParams) {
    if (!derivePathParams || !this.mnemonics)
      return this.currentAddress;
    return getKeyPair(this.mnemonics, derivePathParams).address().toString();
  }
  /**
   * Switch the current account with the given derivePathParams.
   * This is only useful when the mnemonics is provided. For secretKey mode, it will always use the same account.
   */
  switchAccount(derivePathParams) {
    if (this.mnemonics) {
      this.currentKeyPair = getKeyPair(this.mnemonics, derivePathParams);
      this.currentAddress = this.currentKeyPair.address().toString();
    }
  }
};

// src/libs/aptosInteractor/aptosInteractor.ts
import {
  Provider as Provider2,
  FaucetClient,
  TxnBuilderTypes,
  AptosClient,
  IndexerClient,
  Network as Network2
} from "aptos";

// src/libs/aptosInteractor/defaultConfig.ts
import { Network } from "aptos";

// src/types/index.ts
var NetworkNameToIndexerAPI = {
  mainnet: "https://api.mainnet.aptoslabs.com/v1/graphql",
  testnet: "https://api.testnet.aptoslabs.com/v1/graphql",
  devnet: "https://api.devnet.aptoslabs.com/v1/graphql",
  local: "http://127.0.0.1:8090/v1/graphql",
  movementmainnet: "",
  movementtestnet: "",
  movementdevnet: "",
  movementlocal: ""
};

// src/libs/aptosInteractor/defaultConfig.ts
var defaultGasBudget = 10 ** 8;
var getDefaultURL = (networkType = Network.DEVNET) => {
  switch (networkType) {
    case Network.LOCAL:
      return {
        fullNode: "http://127.0.0.1:8080",
        faucet: "http://127.0.0.1:8081"
      };
    case Network.DEVNET:
      return {
        fullNode: "https://fullnode.devnet.aptoslabs.com",
        faucet: "https://faucet.devnet.aptoslabs.com"
      };
    case Network.TESTNET:
      return {
        fullNode: "https://fullnode.testnet.aptoslabs.com",
        faucet: "https://faucet.testnet.aptoslabs.com"
      };
    case Network.MAINNET:
      return {
        fullNode: "https://fullnode.mainnet.aptoslabs.com"
      };
    case "movementdevnet" /* DEVNET */:
      return {
        fullNode: "https://aptos.devnet.m1.movementlabs.xyz",
        faucet: "https://aptos.devnet.m1.movementlabs.xyz"
      };
    case "movementtestnet" /* TESTNET */:
      return {
        fullNode: "https://aptos.testnet.m1.movementlabs.xyz",
        faucet: "https://aptos.testnet.m1.movementlabs.xyz"
      };
    default:
      return {
        fullNode: "https://fullnode.devnet.aptoslabs.com",
        faucet: "https://faucet.devnet.aptoslabs.com"
      };
  }
};

// src/libs/aptosInteractor/util.ts
var delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

// src/libs/aptosInteractor/aptosInteractor.ts
var {
  AccountAddress,
  EntryFunction,
  MultiSig,
  MultiSigTransactionPayload,
  TransactionPayloadMultisig
} = TxnBuilderTypes;
var AptosInteractor = class {
  constructor(fullNodeUrls, network) {
    if (fullNodeUrls.length === 0)
      throw new Error("fullNodeUrls must not be empty");
    this.providers = fullNodeUrls.map(
      (url) => new Provider2({ fullnodeUrl: url, indexerUrl: url })
    );
    this.currentProvider = this.providers[0];
    this.currentClient = new AptosClient(fullNodeUrls[0]);
    this.network = network;
    if (network !== void 0 && network !== Network2.LOCAL && network !== "movementlocal" /* LOCAL */) {
      this.indexerClient = new IndexerClient(NetworkNameToIndexerAPI[network]);
    }
  }
  switchToNextProvider() {
    const currentProviderIdx = this.providers.indexOf(this.currentProvider);
    this.currentProvider = this.providers[(currentProviderIdx + 1) % this.providers.length];
  }
  async signTransaction(sender, rawTxn) {
    try {
      const signedBcsTxn = await this.currentProvider.signTransaction(
        sender,
        rawTxn
      );
      return signedBcsTxn;
    } catch (err) {
      console.warn(`Failed to sign transaction: ${err}`);
      await delay(2e3);
    }
  }
  async submitTransaction(signedTxn) {
    try {
      const pendingTxn = await this.currentProvider.submitTransaction(
        signedTxn
      );
      return pendingTxn;
    } catch (err) {
      console.warn(`Failed to submit transaction: ${err}`);
      await delay(2e3);
    }
  }
  async waitForTransaction(txnHash) {
    try {
      await this.currentProvider.waitForTransaction(txnHash, {
        checkSuccess: true
      });
      return txnHash;
    } catch (err) {
      console.warn(`Failed to sign transaction: ${err}`);
      await delay(2e3);
    }
  }
  async sendTxWithPayload(signer, sender, payload) {
    for (const provider of this.providers) {
      try {
        const rawTxn = await provider.generateTransaction(sender, payload);
        const bcsTxn = AptosClient.generateBCSTransaction(signer, rawTxn);
        const txnHash = await provider.submitSignedBCSTransaction(bcsTxn);
        return txnHash;
      } catch (err) {
        console.warn(
          `Failed to send transaction with fullnode ${provider.nodeUrl}: ${err}`
        );
        await delay(2e3);
      }
    }
    throw new Error("Failed to send transaction with all fullnodes");
  }
  async signAndSubmitTransaction(sender, rawTransaction) {
    for (const provider of this.providers) {
      try {
        const txnHash = await provider.signAndSubmitTransaction(
          sender,
          rawTransaction
        );
        return txnHash;
      } catch (err) {
        console.warn(
          `Failed to send transaction with fullnode ${provider.nodeUrl}: ${err}`
        );
        await delay(2e3);
      }
    }
    throw new Error("Failed to send transaction with all fullnodes");
  }
  async getAccountResources(accountAddress) {
    for (const provider of this.providers) {
      try {
        return provider.getAccountResources(accountAddress);
      } catch (err) {
        await delay(2e3);
        console.warn(
          `Failed to get AccountResources with fullnode ${provider.nodeUrl}: ${err}`
        );
      }
    }
    throw new Error("Failed to get AccountResources with all fullnodes");
  }
  async getAccountResource(accountAddress, resourceType, ledgerVersion) {
    for (const provider of this.providers) {
      try {
        let ledgerVersionBig;
        if (ledgerVersion !== void 0) {
          ledgerVersionBig = BigInt(ledgerVersion);
        }
        return provider.getAccountResource(accountAddress, resourceType, {
          ledgerVersion: ledgerVersionBig
        });
      } catch (err) {
        await delay(2e3);
        console.warn(
          `Failed to get AccountResource with fullnode ${provider.nodeUrl}: ${err}`
        );
      }
    }
    throw new Error("Failed to get AccountResource with all fullnodes");
  }
  async getAccountModule(accountAddress, moduleName, ledgerVersion) {
    for (const provider of this.providers) {
      try {
        let ledgerVersionBig;
        if (ledgerVersion !== void 0) {
          ledgerVersionBig = BigInt(ledgerVersion);
        }
        return provider.getAccountModule(accountAddress, moduleName, {
          ledgerVersion: ledgerVersionBig
        });
      } catch (err) {
        await delay(2e3);
        console.warn(
          `Failed to get AccountModule with fullnode ${provider.nodeUrl}: ${err}`
        );
      }
    }
    throw new Error("Failed to get AccountModule with all fullnodes");
  }
  async getAccountModules(accountAddress) {
    for (const provider of this.providers) {
      try {
        return provider.getAccountModules(accountAddress);
      } catch (err) {
        await delay(2e3);
        console.warn(
          `Failed to get AccountModules with fullnode ${provider.nodeUrl}: ${err}`
        );
      }
    }
    throw new Error("Failed to get AccountModules with all fullnodes");
  }
  async view(contractAddress, moduleName, funcName, typeArguments = [], args = []) {
    for (const provider of this.providers) {
      try {
        let request = {
          function: `${contractAddress}::${moduleName}::${funcName}`,
          type_arguments: typeArguments,
          arguments: args
        };
        return provider.view(request);
      } catch (err) {
        await delay(2e3);
        console.warn(
          `Failed to view with fullnode ${provider.nodeUrl}: ${err}`
        );
      }
    }
    throw new Error("Failed to view with all fullnodes");
  }
  // /**
  //  * @description Update objects in a batch
  //  * @param suiObjects
  //  */
  // async updateObjects(suiObjects: (SuiOwnedObject | SuiSharedObject)[]) {
  //   const objectIds = suiObjects.map((obj) => obj.objectId);
  //   const objects = await this.getObjects(objectIds);
  //   for (const object of objects) {
  //     const suiObject = suiObjects.find(
  //       (obj) => obj.objectId === object.objectId
  //     );
  //     if (suiObject instanceof SuiSharedObject) {
  //       suiObject.initialSharedVersion = object.initialSharedVersion;
  //     } else if (suiObject instanceof SuiOwnedObject) {
  //       suiObject.version = object.objectVersion;
  //       suiObject.digest = object.objectDigest;
  //     }
  //   }
  // }
  // /**
  //  * @description Select coins that add up to the given amount.
  //  * @param addr the address of the owner
  //  * @param amount the amount that is needed for the coin
  //  * @param coinType the coin type, default is '0x2::SUI::SUI'
  //  */
  // async selectCoins(
  //   addr: string,
  //   amount: number,
  //   coinType: string = '0x2::SUI::SUI'
  // ) {
  //   const selectedCoins: {
  //     objectId: string;
  //     digest: string;
  //     version: string;
  //   }[] = [];
  //   let totalAmount = 0;
  //   let hasNext = true,
  //     nextCursor: string | null = null;
  //   while (hasNext && totalAmount < amount) {
  //     const coins = await this.currentProvider.getCoins({
  //       owner: addr,
  //       coinType: coinType,
  //       cursor: nextCursor,
  //     });
  //     // Sort the coins by balance in descending order
  //     coins.data.sort((a, b) => parseInt(b.balance) - parseInt(a.balance));
  //     for (const coinData of coins.data) {
  //       selectedCoins.push({
  //         objectId: coinData.coinObjectId,
  //         digest: coinData.digest,
  //         version: coinData.version,
  //       });
  //       totalAmount = totalAmount + parseInt(coinData.balance);
  //       if (totalAmount >= amount) {
  //         break;
  //       }
  //     }
  //     nextCursor = coins.nextCursor;
  //     hasNext = coins.hasNextPage;
  //   }
  //   if (!selectedCoins.length) {
  //     throw new Error('No valid coins found for the transaction.');
  //   }
  //   return selectedCoins;
  // }
  async requestFaucet(network, accountAddress, amount) {
    const defaultUrl = getDefaultURL(network);
    if (defaultUrl.faucet === void 0) {
      return false;
    }
    try {
      const faucetClient = new FaucetClient(
        defaultUrl.fullNode,
        defaultUrl.faucet
      );
      await faucetClient.fundAccount(accountAddress, amount);
      return true;
    } catch (err) {
      console.warn(`Failed to fund token with faucetClient: ${err}`);
    }
    return false;
  }
};

// src/libs/aptosContractFactory/index.ts
var AptosContractFactory = class {
  // readonly #query: MapMessageQuery<ApiTypes> = {};
  // readonly #tx: MapMessageTx<ApiTypes> = {};
  /**
   * Support the following ways to init the Aptos Dubhe:
   * 1. mnemonics
   * 2. secretKey (base64 or hex)
   * If none of them is provided, will generate a random mnemonics with 24 words.
   *
   * @param mnemonics, 12 or 24 mnemonics words, separated by space
   * @param secretKey, base64 or hex string, when mnemonics is provided, secretKey will be ignored
   */
  constructor({ packageId, metadata } = {}) {
    this.packageId = packageId || "";
    this.metadata = metadata || void 0;
  }
  // getFuncByModuleName(moduleName: string) {
  //   Object.values(this.metadata as Types.MoveModule).forEach((value) => {
  //     const data = value as SuiMoveMoudleValueType;
  //     console.log(`moudle name: ${data.name}`);
  //     // console.log(data.exposedFunctions)
  //     Object.entries(data.exposedFunctions).forEach(([key, value]) => {
  //       console.log(`\tfunc name: ${key}`);
  //       Object.values(value.parameters).forEach((values) => {
  //         // console.log(values)
  //       });
  //     });
  //   });
  // }
  // getAllFunc() {
  //   Object.values(this.metadata as SuiMoveNormalizedModules).forEach(
  //     (value) => {
  //       const data = value as SuiMoveMoudleValueType;
  //       console.log(`moudle name: ${data.name}`);
  //       // console.log(data.exposedFunctions)
  //       Object.entries(data.exposedFunctions).forEach(([key, value]) => {
  //         console.log(`\tfunc name: ${key}`);
  //         console.log(`\t\t${value.parameters.length}`);
  //         Object.values(value.parameters).forEach((values) => {
  //           // console.log(values)
  //           console.log(`\t\targs: ${values}`);
  //         });
  //       });
  //     }
  //   );
  // }
  // getAllModule() {
  //   Object.values(this.metadata as SuiMoveNormalizedModules).forEach(
  //     (value, index) => {
  //       const data = value as SuiMoveMoudleValueType;
  //       console.log(`${index}. ${data.name}`);
  //     }
  //   );
  // }
  //   async call(arguments: ({
  //     kind: "Input";
  //     index: number;
  //     type?: "object" | "pure" | undefined;
  //     value?: any;
  // } | {
  //     kind: "GasCoin";
  // } | {
  //     kind: "Result";
  //     index: number;
  // } | {
  //     kind: "NestedResult";
  //     index: number;
  //     resultIndex: number;
  // })[], derivePathParams?: DerivePathParams) {
  //     const tx = new TransactionBlock();
  //     tx.moveCall({
  //       target: `${this.packageId}::${}::${}`,
  //       arguments,
  //     })
  //     return ;
  //   }
};

// src/dubhe.ts
var {
  AccountAddress: AccountAddress2,
  EntryFunction: EntryFunction2,
  MultiSig: MultiSig2,
  MultiSigTransactionPayload: MultiSigTransactionPayload2,
  TransactionPayloadMultisig: TransactionPayloadMultisig2
} = TxnBuilderTypes2;
function isUndefined(value) {
  return value === void 0;
}
function withMeta(meta, creator) {
  creator.meta = meta;
  return creator;
}
function createQuery(meta, fn) {
  return withMeta(
    meta,
    async (params, typeArguments) => {
      const result = await fn(params, typeArguments);
      return result;
    }
  );
}
function createTx(meta, fn) {
  return withMeta(
    meta,
    async (sender, params, typeArguments, isRaw) => {
      const result = await fn(sender, params, typeArguments, isRaw);
      return result;
    }
  );
}
var _query, _tx, _exec, _read;
var Dubhe = class {
  /**
   * Support the following ways to init the DubheClient:
   * 1. mnemonics
   * 2. secretKey (base64 or hex)
   * If none of them is provided, will generate a random mnemonics with 24 words.
   *
   * @param mnemonics, 12 or 24 mnemonics words, separated by space
   * @param secretKey, base64 or hex string, when mnemonics is provided, secretKey will be ignored
   * @param networkType, 'testnet' | 'mainnet' | 'devnet' | 'localnet', default is 'devnet'
   * @param fullnodeUrl, the fullnode url, default is the preconfig fullnode url for the given network type
   * @param packageId
   */
  constructor({
    mnemonics,
    secretKey,
    networkType,
    fullnodeUrls,
    packageId,
    metadata
  } = {}) {
    __privateAdd(this, _query, {});
    __privateAdd(this, _tx, {});
    __privateAdd(this, _exec, async (meta, sender, params, typeArguments, isRaw) => {
      if (typeArguments === void 0) {
        typeArguments = [];
      }
      if (params === void 0) {
        params = [];
      }
      const payload = await this.generatePayload(
        `${this.contractFactory.packageId}::${meta.moduleName}::${meta.funcName}`,
        typeArguments,
        params
      );
      if (isRaw === true) {
        return payload;
      }
      return await this.signAndSendTxnWithPayload(payload, sender);
    });
    __privateAdd(this, _read, async (meta, params, typeArguments) => {
      if (typeArguments === void 0) {
        typeArguments = [];
      }
      if (params === void 0) {
        params = [];
      }
      return this.aptosInteractor.view(
        meta.contractAddress,
        meta.moduleName,
        meta.funcName,
        typeArguments,
        params
      );
    });
    this.accountManager = new AptosAccountManager({ mnemonics, secretKey });
    fullnodeUrls = fullnodeUrls || [getDefaultURL(networkType).fullNode];
    this.aptosInteractor = new AptosInteractor(fullnodeUrls, networkType);
    this.packageId = packageId;
    if (metadata !== void 0) {
      this.metadata = metadata;
      Object.values(metadata).forEach((metadataRes) => {
        let contractAddress = metadataRes.address;
        let moduleName = metadataRes.name;
        Object.values(metadataRes.exposed_functions).forEach((value) => {
          const meta = {
            contractAddress,
            moduleName,
            funcName: value.name,
            visibility: value.visibility,
            isEntry: value.is_entry,
            isView: value.is_view,
            typeParameters: value.generic_type_params,
            parameters: value.params,
            return: value.return
          };
          if (value.is_view) {
            if (isUndefined(__privateGet(this, _query)[moduleName])) {
              __privateGet(this, _query)[moduleName] = {};
            }
            if (isUndefined(__privateGet(this, _query)[moduleName][value.name])) {
              __privateGet(this, _query)[moduleName][value.name] = createQuery(
                meta,
                (p, type_p) => __privateGet(this, _read).call(this, meta, p, type_p)
              );
            }
          }
          if (value.is_entry) {
            if (isUndefined(__privateGet(this, _tx)[moduleName])) {
              __privateGet(this, _tx)[moduleName] = {};
            }
            if (isUndefined(__privateGet(this, _tx)[moduleName][value.name])) {
              __privateGet(this, _tx)[moduleName][value.name] = createTx(
                meta,
                (s, p, type_p, isRaw) => __privateGet(this, _exec).call(this, meta, s, p, type_p, isRaw)
              );
            }
          }
        });
      });
    }
    this.contractFactory = new AptosContractFactory({
      packageId,
      metadata
    });
  }
  get query() {
    return __privateGet(this, _query);
  }
  get tx() {
    return __privateGet(this, _tx);
  }
  /**
   * if derivePathParams is not provided or mnemonics is empty, it will return the currentSigner.
   * else:
   * it will generate signer from the mnemonic with the given derivePathParams.
   * @param derivePathParams, such as { accountIndex: 2, isExternal: false, addressIndex: 10 }, comply with the BIP44 standard
   */
  getSigner(derivePathParams) {
    const keyPair = this.accountManager.getKeyPair(derivePathParams);
    return keyPair;
  }
  /**
   * @description Switch the current account with the given derivePathParams
   * @param derivePathParams, such as { accountIndex: 2, isExternal: false, addressIndex: 10 }, comply with the BIP44 standard
   */
  switchAccount(derivePathParams) {
    this.accountManager.switchAccount(derivePathParams);
  }
  /**
   * @description Get the address of the account for the given derivePathParams
   * @param derivePathParams, such as { accountIndex: 2, isExternal: false, addressIndex: 10 }, comply with the BIP44 standard
   */
  getAddress(derivePathParams) {
    return this.accountManager.getAddress(derivePathParams);
  }
  currentAddress() {
    return this.accountManager.currentAddress;
  }
  provider() {
    return this.aptosInteractor.currentProvider;
  }
  getPackageId() {
    return this.contractFactory.packageId;
  }
  getMetadata() {
    return this.contractFactory.metadata;
  }
  /**
   * Request some APT from faucet
   * @Returns {Promise<boolean>}, true if the request is successful, false otherwise.
   */
  async requestFaucet(network, accountAddress, amount) {
    if (network === Network3.MAINNET) {
      return false;
    }
    if (accountAddress === void 0) {
      accountAddress = this.getAddress();
    }
    if (amount === void 0) {
      amount = 5e7;
    }
    return this.aptosInteractor.requestFaucet(network, accountAddress, amount);
  }
  async getBalance(accountAddress, coinType) {
    try {
      if (accountAddress === void 0) {
        accountAddress = this.getAddress();
      }
      if (coinType === void 0) {
        coinType = "0x1::aptos_coin::AptosCoin";
      }
      const resource = await this.aptosInteractor.getAccountResource(
        accountAddress,
        `0x1::coin::CoinStore<${coinType}>`
      );
      return parseInt(resource.data["coin"]["value"]);
    } catch (_) {
      return 0;
    }
  }
  async signAndSendTxnWithPayload(payload, sender, derivePathParams) {
    const signer = this.getSigner(derivePathParams);
    if (sender === void 0) {
      sender = signer.address();
    }
    if (typeof sender === "string") {
      sender = new HexString2(sender);
    }
    return this.aptosInteractor.sendTxWithPayload(signer, sender, payload);
  }
  async generatePayload(target, typeArguments, params) {
    const payload = {
      function: target,
      // `${contractAddress}::${moduleName}::${funcName}`
      type_arguments: typeArguments,
      arguments: params
    };
    return payload;
  }
  async generateTransaction(sender, contractAddress, moduleName, funcName, typeArguments, params) {
    const rawTxn = await this.aptosInteractor.currentClient.generateTransaction(
      sender,
      {
        function: `${contractAddress}::${moduleName}::${funcName}`,
        type_arguments: typeArguments,
        arguments: params
      }
    );
    return rawTxn;
  }
  async waitForTransaction(txnHash) {
    return this.aptosInteractor.waitForTransaction(txnHash);
  }
  async signAndSendTxn(tx, derivePathParams) {
    const sender = this.getSigner(derivePathParams);
    return this.aptosInteractor.signAndSubmitTransaction(sender, tx);
  }
  async getEntity(schemaName, entityId) {
    const schemaModuleName = `${schemaName}_schema`;
    let params = [];
    if (entityId !== void 0) {
      params.push(entityId);
    }
    const result = await this.query[schemaModuleName].get(void 0, params);
    return result;
  }
  async containEntity(schemaName, entityId) {
    const schemaModuleName = `${schemaName}_schema`;
    let params = [];
    if (entityId !== void 0) {
      params.push(entityId);
    }
    const result = await this.query[schemaModuleName].contains(
      void 0,
      params
    );
    return result[0];
  }
};
_query = new WeakMap();
_tx = new WeakMap();
_exec = new WeakMap();
_read = new WeakMap();

// src/metadata/index.ts
async function loadMetadata(networkType, packageId) {
  const fullnodeUrls = [getDefaultURL(networkType).fullNode];
  const aptosInteractor = new AptosInteractor(fullnodeUrls);
  if (packageId !== void 0) {
    const jsonData = await aptosInteractor.getAccountModules(packageId);
    return jsonData.map((data) => data.abi);
  } else {
    console.error("please set your package id.");
  }
}
export {
  AptosAccountManager,
  AptosContractFactory,
  AptosInteractor,
  Dubhe,
  getDefaultURL,
  loadMetadata
};
//# sourceMappingURL=index.mjs.map